// @HEADER
//
// ***********************************************************************
//
//        MueLu: A package for multigrid based preconditioning
//                  Copyright 2012 Sandia Corporation
//
// Under the terms of Contract DE-AC04-94AL85000 with Sandia Corporation,
// the U.S. Government retains certain rights in this software.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
// 1. Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//
// 2. Redistributions in binary form must reproduce the above copyright
// notice, this list of conditions and the following disclaimer in the
// documentation and/or other materials provided with the distribution.
//
// 3. Neither the name of the Corporation nor the names of the
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY SANDIA CORPORATION "AS IS" AND ANY
// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
// PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL SANDIA CORPORATION OR THE
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// Questions? Contact
//                    Jonathan Hu       (jhu@sandia.gov)
//                    Andrey Prokopenko (aprokop@sandia.gov)
//                    Ray Tuminaro      (rstumin@sandia.gov)
//
// ***********************************************************************
//
// @HEADER
#ifndef MUELU_BLACKBOXPFACTORY_DEF_HPP
#define MUELU_BLACKBOXPFACTORY_DEF_HPP

#include <stdlib.h>
#include <iomanip>


// #include <Teuchos_LAPACK.hpp>
#include <Teuchos_SerialDenseMatrix.hpp>
#include <Teuchos_SerialDenseVector.hpp>
#include <Teuchos_SerialDenseSolver.hpp>

#include <Xpetra_CrsMatrixUtils.hpp>
#include <Xpetra_CrsMatrixWrap.hpp>
#include <Xpetra_CrsGraphFactory.hpp>
#include <Xpetra_CrsGraph.hpp>
#include <Xpetra_ImportFactory.hpp>
#include <Xpetra_Matrix.hpp>
#include <Xpetra_MapFactory.hpp>
#include <Xpetra_MultiVectorFactory.hpp>
#include <Xpetra_VectorFactory.hpp>

#include <Xpetra_IO.hpp>

#include "MueLu_MasterList.hpp"
#include "MueLu_Monitor.hpp"
#include "MueLu_FactoryManagerBase.hpp"
#include "MueLu_BlackBoxConnectivity.hpp"
#include "MueLu_BlackBoxPFactory_decl.hpp"


namespace MueLu {

  template <class Scalar, class LocalOrdinal, class GlobalOrdinal, class Node>
  RCP<const ParameterList> BlackBoxPFactory<Scalar, LocalOrdinal, GlobalOrdinal, Node>::GetValidParameterList() const {
    RCP<ParameterList> validParamList = rcp(new ParameterList());

    // Coarsen can come in two forms, either a single char that will be interpreted as an integer
    // which is used as the coarsening rate in every spatial dimentions,
    // or it can be a longer string that will then be interpreted as an array of integers.
    // By default coarsen is set as "{2}", hence a coarsening rate of 2 in every spatial dimension
    // is the default setting!
    validParamList->set<std::string >           ("Coarsen",                 "{3}", "Coarsening rate in all spatial dimensions");
    validParamList->set<RCP<const FactoryBase> >("A",                         Teuchos::null, "Generating factory of the matrix A");
    validParamList->set<RCP<const FactoryBase> >("Nullspace",                 Teuchos::null, "Generating factory of the nullspace");
    validParamList->set<RCP<const FactoryBase> >("Coordinates",               Teuchos::null, "Generating factory for coorindates");
    validParamList->set<RCP<const FactoryBase> >("gFineNodesPerDir",              Teuchos::null, "Number of nodes per spatial dimmension provided by CoordinatesTransferFactory.");
    validParamList->set<RCP<const FactoryBase> >("lFineNodesPerDir",              Teuchos::null, "Number of nodes per spatial dimmension provided by CoordinatesTransferFactory.");
    validParamList->set<RCP<const FactoryBase> >("prolongatorGraph",          Teuchos::null, "Graph generated by StructuredAggregationFactory used to construct a piece-linear prolongator.");
    validParamList->set<RCP<const FactoryBase> >("BlackBoxConnectivity",      Teuchos::null, "Connectivity object generated by StructuredAggregationFactory.");
    validParamList->set<std::string>            ("axisPermutation",         "", "Assuming a global (x,y,z) orientation, local might be (z,y,x). This vector gives a permutation from global to local orientation.");
    validParamList->set<std::string>            ("stencil type",            "full", "You can use two type of stencils: full and reduced, that correspond to 27 and 7 points stencils respectively in 3D.");
    validParamList->set<std::string>            ("block strategy",          "coupled", "The strategy used to handle systems of PDEs can be: coupled or uncoupled.");

    return validParamList;
  }

  template <class Scalar,class LocalOrdinal, class GlobalOrdinal, class Node>
  void BlackBoxPFactory<Scalar, LocalOrdinal, GlobalOrdinal, Node>::DeclareInput(Level& level,
                                                                                 Level& coarseLevel)
    const {
    Input(level, "A");
    Input(level, "Nullspace");
    Input(level, "Coordinates");
    Input(level, "prolongatorGraph");
    Input(level, "BlackBoxConnectivity");
    // Request the global number of nodes per dimensions
    if(level.GetLevelID() == 0) {
      if(level.IsAvailable("gFineNodesPerDir", NoFactory::get())) {
        level.DeclareInput("gFineNodesPerDir", NoFactory::get(), this);
      } else {
        TEUCHOS_TEST_FOR_EXCEPTION(level.IsAvailable("gFineNodesPerDir", NoFactory::get()),
                                   Exceptions::RuntimeError,
                                   "gFineNodesPerDir was not provided by the user on level0!");
      }
    } else {
      Input(level, "gFineNodesPerDir");
    }

    // Request the local number of nodes per dimensions
    if(level.GetLevelID() == 0) {
      if(level.IsAvailable("lFineNodesPerDir", NoFactory::get())) {
        level.DeclareInput("lFineNodesPerDir", NoFactory::get(), this);
      } else {
        TEUCHOS_TEST_FOR_EXCEPTION(level.IsAvailable("lFineNodesPerDir", NoFactory::get()),
                                   Exceptions::RuntimeError,
                                   "lFineNodesPerDir was not provided by the user on level0!");
      }
    } else {
      Input(level, "lFineNodesPerDir");
    }
  }

  template <class Scalar,class LocalOrdinal, class GlobalOrdinal, class Node>
  void BlackBoxPFactory<Scalar, LocalOrdinal, GlobalOrdinal, Node>::Build(Level& level,
                                                                          Level& coarseLevel) const{
    return BuildP(level, coarseLevel);

  }

  template <class Scalar, class LocalOrdinal, class GlobalOrdinal, class Node>
  void BlackBoxPFactory<Scalar, LocalOrdinal, GlobalOrdinal, Node>::
  BuildPCrs(Level& level, RCP<CrsGraph>& prolongatorGraph,
            RCP<BlackBoxConnectivity>& BBConnectivity) const{
    std::cout << "----------------------------------------------------------" << std::endl;
    std::cout << "Entering BuildPCrs" << std::endl;
    std::cout << "----------------------------------------------------------" << std::endl;
    // Get parameter list
    FactoryMonitor m(*this, "Build", level);
    const ParameterList& pL = GetParameterList();
    RCP<Xpetra::MultiVector<double,LO,GO,NO> > coordinates =
      Get< RCP<Xpetra::MultiVector<double,LO,GO,NO> > >(level, "Coordinates");
    RCP<Matrix>      A             = Get< RCP<Matrix> >      (level, "A");
    //TODO: get dimension
    LO numDimensions  = 3;
    LO BlkSize = A->GetFixedBlockSize();
    // Get fine level geometric data: g(l)FineNodesPerDir and g(l)NumFineNodes
    Array<GO> gFineNodesPerDir(3);
    Array<LO> lFineNodesPerDir(3);
    // Get the number of points in each direction
    if(level.GetLevelID() == 0) {
      gFineNodesPerDir = level.Get<Array<GO> >("gFineNodesPerDir", NoFactory::get());
      lFineNodesPerDir = level.Get<Array<LO> >("lFineNodesPerDir", NoFactory::get());
    } else {
      // Loading global number of nodes per diretions
      gFineNodesPerDir = Get<Array<GO> >(level, "gFineNodesPerDir");

      // Loading local number of nodes per diretions
      lFineNodesPerDir = Get<Array<LO> >(level, "lFineNodesPerDir");
    }
    for(LO i = 0; i < 3; ++i) {
      if(gFineNodesPerDir[i] == 0) {
        GetOStream(Runtime0) << "gFineNodesPerDir in direction " << i << " is set to 1 from 0"
                             << std::endl;
        gFineNodesPerDir[i] = 1;
      }
      if(lFineNodesPerDir[i] == 0) {
        GetOStream(Runtime0) << "lFineNodesPerDir in direction " << i << " is set to 1 from 0"
                             << std::endl;
        lFineNodesPerDir[i] = 1;
      }
    }
    GO gNumFineNodes = gFineNodesPerDir[2]*gFineNodesPerDir[1]*gFineNodesPerDir[0];
    LO lNumFineNodes = lFineNodesPerDir[2]*lFineNodesPerDir[1]*lFineNodesPerDir[0];

    // Get the coarsening rate
    std::string coarsenRate = pL.get<std::string>("Coarsen");
    Array<LO> coarseRate(3);
    {
      Teuchos::Array<LO> crates;
      try {
        crates = Teuchos::fromStringToArray<LO>(coarsenRate);
      } catch(const Teuchos::InvalidArrayStringRepresentation e) {
        GetOStream(Errors,-1) << " *** Coarsen must be a string convertible into an array! *** "
                              << std::endl;
        throw e;
      }
      TEUCHOS_TEST_FOR_EXCEPTION((crates.size() > 1) && (crates.size() < numDimensions),
                                 Exceptions::RuntimeError,
                                 "Coarsen must have at least as many components as the number of"
                                 " spatial dimensions in the problem.");
      for(LO i = 0; i < 3; ++i) {
        if(i < numDimensions) {
          if(crates.size() == 1) {
            coarseRate[i] = crates[0];
          } else if(i < crates.size()) {
            coarseRate[i] = crates[i];
          } else {
            GetOStream(Errors,-1) << " *** Coarsen must be at least as long as the number of"
              " spatial dimensions! *** " << std::endl;
            throw Exceptions::RuntimeError(" *** Coarsen must be at least as long as the number of"
                                           " spatial dimensions! *** \n");
          }
        } else {
          coarseRate[i] = 1;
        }
      }
    } // End of scope for crates

    // Get the stencil type used for discretization
    const std::string stencilType = pL.get<std::string>("stencil type");
    if(stencilType != "full" && stencilType != "reduced") {
      GetOStream(Errors,-1) << " *** stencil type must be set to: full or reduced, any other value "
              "is trated as an error! *** " << std::endl;
      throw Exceptions::RuntimeError(" *** stencil type is neither full, nor reduced! *** \n");
    }

    // Get the strategy for PDE systems
    const std::string blockStrategy = pL.get<std::string>("block strategy");
    //std::cout << "blockStrategy = " << blockStrategy << std::endl;
    if(blockStrategy != "coupled" && blockStrategy != "uncoupled") {
      GetOStream(Errors,-1) << " *** block strategy must be set to: coupled or uncoupled, any other "
              "value is trated as an error! *** " << std::endl;
      throw Exceptions::RuntimeError(" *** block strategy is neither coupled, nor uncoupled! *** \n");
    }

    Array<LO> myOffset(3), lCoarseNodesPerDir(3), endRate(3);
    Array<GO> gCoarseNodesPerDir(3), gIndices(3);
    Array<int> boundaryFlags(3);
    //Array<ArrayView<const double> > fineNodes(numDimensions);
    //for(LO dim = 0; dim < numDimensions; ++dim) {fineNodes[dim] = coordinates->getData(dim)();}

    // This struct stores PIDs, LIDs and GIDs on the fine mesh and GIDs on the coarse mesh.
    RCP<NodesIDs> ghostedCoarseNodes = rcp(new NodesIDs{});
    GenerateCoarseInfo(coarseRate, gFineNodesPerDir, prolongatorGraph,
                       lFineNodesPerDir, BlkSize, numDimensions, endRate,
                       myOffset, gCoarseNodesPerDir, 
                       lCoarseNodesPerDir, boundaryFlags, gIndices);
    
    // Unamalgamating map from prolongator, this should go away after small refactor of structured
    // aggregation factory to have it construct the true prolongatorGraph.
    ArrayView<const GO> initialRowMapGIDs = prolongatorGraph->getRowMap()->getNodeElementList();
    Array<GO> rowMapGIDs(initialRowMapGIDs.size()*BlkSize);
    for(LO elementIdx = 0;
        elementIdx < as<LO>(prolongatorGraph->getRowMap()->getNodeNumElements());
        ++elementIdx) {
      for(int dof = 0; dof < BlkSize; ++dof) {
        rowMapGIDs[elementIdx*BlkSize + dof] = initialRowMapGIDs[elementIdx]*BlkSize + dof;
      }
    }
    RCP<Map> ghostedRowMap = MapFactory::Build(prolongatorGraph->getRowMap()->lib(),
                                               prolongatorGraph->getGlobalNumRows()*BlkSize,
                                               rowMapGIDs(),
                                               prolongatorGraph->getIndexBase(),
                                               prolongatorGraph->getComm(),
                                               prolongatorGraph->getColMap()->getNode());

    ArrayView<const GO> initialColMapGIDs = prolongatorGraph->getColMap()->getNodeElementList();
    Array<GO> colMapGIDs(initialColMapGIDs.size()*BlkSize);
    for(LO elementIdx = 0;
        elementIdx < as<LO>(prolongatorGraph->getColMap()->getNodeNumElements());
        ++elementIdx) {
      for(int dof = 0; dof < BlkSize; ++dof) {
        colMapGIDs[elementIdx*BlkSize + dof] = initialColMapGIDs[elementIdx]*BlkSize + dof;
      }
    }
    RCP<Map> ghostedColMap = MapFactory::Build(prolongatorGraph->getColMap()->lib(),
                                               prolongatorGraph->getGlobalNumCols()*BlkSize,
                                               colMapGIDs(),
                                               prolongatorGraph->getIndexBase(),
                                               prolongatorGraph->getComm(),
                                               prolongatorGraph->getRowMap()->getNode());

    std::cout << "ghostedRowMap: " << ghostedRowMap->getNodeElementList() << std::endl;
    std::cout << "ghostedColMap: " << ghostedColMap->getNodeElementList() << std::endl;

    RCP<const Import> ghostImporter = Xpetra::ImportFactory<LO,GO,NO>::Build(A->getRowMap(),
                                                                             ghostedRowMap);

    RCP<const Matrix> Aghosted      = Xpetra::MatrixFactory<SC,LO,GO,NO>::Build(A, *ghostImporter,
                                                                                ghostedRowMap,
                                                                                ghostedRowMap);
    LO lNumCoarseNodes = lCoarseNodesPerDir[0]*lCoarseNodesPerDir[1]*lCoarseNodesPerDir[2];
    std::cout << "lNumCoarseNodes: " << lNumCoarseNodes << std::endl;
    // Create the maps and data structures for the projection matrix
    RCP<const Map> rowMapP    = A->getDomainMap();

    RCP<const Map> domainMapP;

    RCP<const Map> colMapP;

    // DomainMap and colMap of our P should be exactly the ones provided
    // by the wonderful prolongatorGraph.
    domainMapP = prolongatorGraph->getRowMap();
    colMapP    = prolongatorGraph->getColMap();

    std::vector<size_t> strideInfo(1);
    strideInfo[0] = BlkSize;
    RCP<const Map> stridedDomainMapP = Xpetra::StridedMapFactory<LO,GO,NO>::Build(domainMapP,
                                                                                  strideInfo);
    // Create the matrix itself using the above maps
    RCP<Matrix> P;
    P = rcp(new CrsMatrixWrap(rowMapP, colMapP, 0, Xpetra::StaticProfile));
    RCP<CrsMatrix> PCrs = rcp_dynamic_cast<CrsMatrixWrap>(P)->getCrsMatrix();

    ArrayRCP<size_t>  iaP;
    ArrayRCP<LO>      jaP;
    ArrayRCP<SC>     valP;

    LO lnnzP = 0;
    // coarse points have one nnz per row
    lnnzP += lNumCoarseNodes;
    // add all other points multiplying by 2^numDimensions
    lnnzP += (lNumFineNodes - lNumCoarseNodes)*std::pow(2, numDimensions);
    // finally multiply by the number of dofs per node
    lnnzP = lnnzP*BlkSize;
    std::cout << "lnnzP: " << lnnzP << std::endl;


    PCrs->allocateAllValues(lnnzP, iaP, jaP, valP);

    ArrayView<size_t> ia  = iaP();
    ArrayView<LO>     ja  = jaP();
    ArrayView<SC>     val = valP();
    ia[0] = 0;

    LO numCoarseElements = 1;

    // Loop over the coarse elements using connectivity
    Array<int> elementFlags(3);
    Array<LO> elemInds(3), elementNodesPerDir(3), glElementRefTuple(3);
    Array<LO> glElementRefTupleCG(3), glElementCoarseNodeCG(8);
    const int numCoarseNodesInElement = std::pow(2, numDimensions);
    const int nnzPerCoarseNode = (blockStrategy == "coupled") ? BlkSize : 1;
    const int numRowsPerPoint = BlkSize;
    Array<typename BlackBoxConnectivity::elementEntry> elementsData = BBConnectivity->elementsData;
    Array<LO> connectivity0 = elementsData[0].connectivity_;
    for (size_t i = 0; i < elementsData.size(); ++i) {
      typename BlackBoxConnectivity::elementEntry element = elementsData[i];
      Array<LO> connectivity = element.connectivity_;
      elementFlags = element.isMeshEdge_;
      elementNodesPerDir = element.dimensions_;
      std::cout << "elementNodesPerDir= " << elementNodesPerDir << std::endl;
      LO numNodesInElement = connectivity.size();
      std::cout << "numNodesInElement " << numNodesInElement << std::endl;
      // elemLabel should be the number of it's lower right corner, which
      // is its first node
      LO elemLabel = connectivity[0];
      std::cout << "elemLabel = " << elemLabel << std::endl;
      LO ke = 0, je = 0, ie = 0;
      GetIJKfromIndex(elemLabel, lFineNodesPerDir, ie, je, ke);
      std::cout << "ie = " << ie << " je = " << je << " ke = " << ke << std::endl;
      elemInds[0] = ie; elemInds[1] = je; elemInds[2] = ke;
      Array<LO> dofType(numNodesInElement*BlkSize), lDofInd(numNodesInElement*BlkSize);
      // Compute Pi, Pe, Pf for the current coarse element
      Teuchos::SerialDenseMatrix<LO,SC> Pi, Pf, Pe;
      ComputeLocalEntries(Aghosted, coarseRate, BlkSize, elemInds,
                          numDimensions, lFineNodesPerDir, connectivity,
                          elementFlags, stencilType, blockStrategy, elementNodesPerDir,
                          numNodesInElement, Pi, Pf, Pe, dofType, lDofInd);
      // Move data into arrayviews to be fanned out to global P
      ExtractFromLocal(Pi, Pf, Pe, numNodesInElement, elementNodesPerDir, connectivity,
                       lFineNodesPerDir, numDimensions, coarseRate, glElementCoarseNodeCG, 
                       glElementRefTuple, myOffset, dofType, lDofInd, elemInds, BlkSize, 
                       nnzPerCoarseNode, ghostedCoarseNodes, blockStrategy, lCoarseNodesPerDir, 
                       ia, ja, val);
    }
    // Sort all row's column indicies and entries by LID
    Xpetra::CrsMatrixUtils<SC,LO,GO,NO>::sortCrsEntries(ia, ja, val, rowMapP->lib());

    // Set the values of the prolongation operators into the CrsMatrix P and call FillComplete
    PCrs->setAllValues(iaP, jaP, valP);
    PCrs->expertStaticFillComplete(domainMapP,rowMapP);

    Xpetra::IO<SC,LO,GO,NO>::Write("CleanedBlackBoxProlongator.m", *P);

    // set StridingInformation of P
    if (A->IsView("stridedMaps") == true) {
      std::cout << "A->IsView(stridedMaps) == true)" << std::endl;
      P->CreateView("stridedMaps", A->getRowMap("stridedMaps"), stridedDomainMapP);
    } else {
      P->CreateView("stridedMaps", PCrs->getRangeMap(), stridedDomainMapP);
    }

    //// store the transfer operator and node coordinates on coarse level
    Set(level, "P", P);
    //Set(coarseLevel, "coarseCoordinates", coarseCoordinates);
    //Set<Array<GO> >(coarseLevel, "gCoarseNodesPerDim", gCoarseNodesPerDir);
    //Set<Array<LO> >(coarseLevel, "lCoarseNodesPerDim", lCoarseNodesPerDir);
  }

  template <class Scalar,class LocalOrdinal, class GlobalOrdinal, class Node>
  void BlackBoxPFactory<Scalar, LocalOrdinal, GlobalOrdinal, Node>::BuildP(Level& level,
                                                                           Level& coarseLevel)const{
    FactoryMonitor m(*this, "Build", coarseLevel);

    // Get parameter list
    const ParameterList& pL = GetParameterList();

    // obtain general variables
    RCP<Matrix>      A             = Get< RCP<Matrix> >      (level, "A");
    RCP<MultiVector> fineNullspace = Get< RCP<MultiVector> > (level, "Nullspace");
    RCP<Xpetra::MultiVector<double,LO,GO,NO> > coordinates =
      Get< RCP<Xpetra::MultiVector<double,LO,GO,NO> > >(level, "Coordinates");
    LO numDimensions  = coordinates->getNumVectors();
    LO BlkSize = A->GetFixedBlockSize();

    // Get fine level geometric data: g(l)FineNodesPerDir and g(l)NumFineNodes
    Array<GO> gFineNodesPerDir(3);
    Array<LO> lFineNodesPerDir(3);
    // Get the number of points in each direction
    if(level.GetLevelID() == 0) {
      gFineNodesPerDir = level.Get<Array<GO> >("gFineNodesPerDir", NoFactory::get());
      lFineNodesPerDir = level.Get<Array<LO> >("lFineNodesPerDir", NoFactory::get());
    } else {
      // Loading global number of nodes per diretions
      gFineNodesPerDir = Get<Array<GO> >(level, "gFineNodesPerDir");

      // Loading local number of nodes per diretions
      lFineNodesPerDir = Get<Array<LO> >(level, "lFineNodesPerDir");
    }
    for(LO i = 0; i < 3; ++i) {
      if(gFineNodesPerDir[i] == 0) {
        GetOStream(Runtime0) << "gFineNodesPerDir in direction " << i << " is set to 1 from 0"
                             << std::endl;
        gFineNodesPerDir[i] = 1;
      }
      if(lFineNodesPerDir[i] == 0) {
        GetOStream(Runtime0) << "lFineNodesPerDir in direction " << i << " is set to 1 from 0"
                             << std::endl;
        lFineNodesPerDir[i] = 1;
      }
    }
    GO gNumFineNodes = gFineNodesPerDir[2]*gFineNodesPerDir[1]*gFineNodesPerDir[0];
    LO lNumFineNodes = lFineNodesPerDir[2]*lFineNodesPerDir[1]*lFineNodesPerDir[0];

    // Get the coarsening rate
    std::string coarsenRate = pL.get<std::string>("Coarsen");
    Array<LO> coarseRate(3);
    {
      Teuchos::Array<LO> crates;
      try {
        crates = Teuchos::fromStringToArray<LO>(coarsenRate);
      } catch(const Teuchos::InvalidArrayStringRepresentation e) {
        GetOStream(Errors,-1) << " *** Coarsen must be a string convertible into an array! *** "
                              << std::endl;
        throw e;
      }
      TEUCHOS_TEST_FOR_EXCEPTION((crates.size() > 1) && (crates.size() < numDimensions),
                                 Exceptions::RuntimeError,
                                 "Coarsen must have at least as many components as the number of"
                                 " spatial dimensions in the problem.");
      for(LO i = 0; i < 3; ++i) {
        if(i < numDimensions) {
          if(crates.size() == 1) {
            coarseRate[i] = crates[0];
          } else if(i < crates.size()) {
            coarseRate[i] = crates[i];
          } else {
            GetOStream(Errors,-1) << " *** Coarsen must be at least as long as the number of"
              " spatial dimensions! *** " << std::endl;
            throw Exceptions::RuntimeError(" *** Coarsen must be at least as long as the number of"
                                           " spatial dimensions! *** \n");
          }
        } else {
          coarseRate[i] = 1;
        }
      }
    } // End of scope for crates

    // Get the stencil type used for discretization
    const std::string stencilType = pL.get<std::string>("stencil type");
    if(stencilType != "full" && stencilType != "reduced") {
      GetOStream(Errors,-1) << " *** stencil type must be set to: full or reduced, any other value "
              "is trated as an error! *** " << std::endl;
      throw Exceptions::RuntimeError(" *** stencil type is neither full, nor reduced! *** \n");
    }

    // Get the strategy for PDE systems
    const std::string blockStrategy = pL.get<std::string>("block strategy");
    if(blockStrategy != "coupled" && blockStrategy != "uncoupled") {
      GetOStream(Errors,-1) << " *** block strategy must be set to: coupled or uncoupled, any other "
              "value is trated as an error! *** " << std::endl;
      throw Exceptions::RuntimeError(" *** block strategy is neither coupled, nor uncoupled! *** \n");
    }

    GO gNumCoarseNodes = 0;
    LO lNumCoarseNodes = 0;
    Array<GO> gIndices(3), gCoarseNodesPerDir(3), ghostGIDs, coarseNodesGIDs, colGIDs;
    Array<LO> myOffset(3), lCoarseNodesPerDir(3), glCoarseNodesPerDir(3), endRate(3);
    Array<bool> ghostInterface(6);
    Array<int> boundaryFlags(3);
    ArrayRCP<Array<double> > coarseNodes(numDimensions);
    Array<ArrayView<const double> > fineNodes(numDimensions);
    for(LO dim = 0; dim < numDimensions; ++dim) {fineNodes[dim] = coordinates->getData(dim)();}

    // This struct stores PIDs, LIDs and GIDs on the fine mesh and GIDs on the coarse mesh.
    RCP<NodesIDs> ghostedCoarseNodes = rcp(new NodesIDs{});

    GetGeometricData(coordinates, coarseRate, gFineNodesPerDir, lFineNodesPerDir, BlkSize,// inputs
                     gIndices, myOffset, ghostInterface, endRate, gCoarseNodesPerDir,     // outputs
                     lCoarseNodesPerDir, glCoarseNodesPerDir, ghostGIDs, coarseNodesGIDs, colGIDs,
                     gNumCoarseNodes, lNumCoarseNodes, coarseNodes, boundaryFlags,
                     ghostedCoarseNodes);

    // Create the MultiVector of coarse coordinates
    Xpetra::UnderlyingLib lib = coordinates->getMap()->lib();
    RCP<const Map> coarseCoordsMap = MapFactory::Build (lib,
                                                        gNumCoarseNodes,
                                                        coarseNodesGIDs.view(0, lNumCoarseNodes),
                                                        coordinates->getMap()->getIndexBase(),
                                                        coordinates->getMap()->getComm());
    Array<ArrayView<const double> > coarseCoords(numDimensions);
    for(LO dim = 0; dim < numDimensions; ++dim) {
      coarseCoords[dim] = coarseNodes[dim]();
    }
    RCP<Xpetra::MultiVector<double,LO,GO,NO> > coarseCoordinates =
      Xpetra::MultiVectorFactory<double,LO,GO,NO>::Build(coarseCoordsMap, coarseCoords(),
                                                         numDimensions);

    // Now create a new matrix: Aghost that contains all the data
    // locally needed to compute the local part of the prolongator.
    // Here assuming that all the coarse nodes o and fine nodes +
    // are local then all the data associated with the coarse
    // nodes O and the fine nodes * needs to be imported.
    //
    //                  *--*--*--*--*--*--*--*
    //                  |  |  |  |  |  |  |  |
    //                  o--+--+--o--+--+--O--*
    //                  |  |  |  |  |  |  |  |
    //                  +--+--+--+--+--+--*--*
    //                  |  |  |  |  |  |  |  |
    //                  +--+--+--+--+--+--*--*
    //                  |  |  |  |  |  |  |  |
    //                  o--+--+--o--+--+--O--*
    //                  |  |  |  |  |  |  |  |
    //                  +--+--+--+--+--+--*--*
    //                  |  |  |  |  |  |  |  |
    //                  *--*--*--*--*--*--*--*
    //                  |  |  |  |  |  |  |  |
    //                  O--*--*--O--*--*--O--*
    //
    // Creating that local matrix is easy enough using proper range
    // and domain maps to import data from A. Note that with this
    // approach we reorder the local entries using the domain map and
    // can subsequently compute the prolongator without reordering.
    // As usual we need to be careful about any coarsening rate
    // change at the boundary!

    // The ingredients needed are an importer, a range map and a domain map
    Array<GO> ghostRowGIDs, ghostColGIDs, nodeSteps(3);
    nodeSteps[0] = 1;
    nodeSteps[1] = gFineNodesPerDir[0];
    nodeSteps[2] = gFineNodesPerDir[0]*gFineNodesPerDir[1];
    Array<LO> glFineNodesPerDir(3);
    GO startingGID = A->getRowMap()->getMinGlobalIndex();
    for(LO dim = 0; dim < 3; ++dim) {
      LO numCoarseNodes = 0;
      if(dim < numDimensions) {
        startingGID -= myOffset[dim]*nodeSteps[dim];
        numCoarseNodes = lCoarseNodesPerDir[dim];
        if(ghostInterface[2*dim]) {++numCoarseNodes;}
        if(ghostInterface[2*dim+1]) {++numCoarseNodes;}
        if(gIndices[dim] + lFineNodesPerDir[dim] == gFineNodesPerDir[dim]) {
          glFineNodesPerDir[dim] = (numCoarseNodes - 2)*coarseRate[dim] + endRate[dim] + 1;
        } else {
          glFineNodesPerDir[dim] = (numCoarseNodes - 1)*coarseRate[dim] + 1;
        }
      } else {
        glFineNodesPerDir[dim] = 1;
      }
    }
    ghostRowGIDs.resize(glFineNodesPerDir[0]*glFineNodesPerDir[1]*glFineNodesPerDir[2]*BlkSize);
    for(LO k = 0; k < glFineNodesPerDir[2]; ++k) {
      for(LO j = 0; j < glFineNodesPerDir[1]; ++j) {
        for(LO i = 0; i < glFineNodesPerDir[0]; ++i) {
          for(LO l = 0; l < BlkSize; ++l) {
            ghostRowGIDs[(k*glFineNodesPerDir[1]*glFineNodesPerDir[0]
                          + j*glFineNodesPerDir[0] + i)*BlkSize + l] = startingGID
              + (k*gFineNodesPerDir[1]*gFineNodesPerDir[0] + j*gFineNodesPerDir[0] + i)*BlkSize + l;
          }
        }
      }
    }

    // Looking at the above loops it is easy to find startingGID for the ghostColGIDs
    Array<GO> startingGlobalIndices(numDimensions), dimStride(numDimensions);
    Array<GO> startingColIndices(numDimensions), finishingColIndices(numDimensions);
    GO colMinGID = 0;
    Array<LO> colRange(numDimensions);
    dimStride[0] = 1;
    for(int dim = 1; dim < numDimensions; ++dim) {
      dimStride[dim] = dimStride[dim - 1]*gFineNodesPerDir[dim - 1];
    }
    {
      GO tmp = startingGID;
      for(int dim = numDimensions; dim > 0; --dim) {
        startingGlobalIndices[dim - 1] = tmp / dimStride[dim - 1];
        tmp = tmp % dimStride[dim - 1];

        if(startingGlobalIndices[dim - 1] > 0) {
          startingColIndices[dim - 1] = startingGlobalIndices[dim - 1] - 1;
        }
        if(startingGlobalIndices[dim - 1] + glFineNodesPerDir[dim - 1] < gFineNodesPerDir[dim - 1]){
          finishingColIndices[dim - 1] = startingGlobalIndices[dim - 1]
            + glFineNodesPerDir[dim - 1];
        } else {
          finishingColIndices[dim - 1] = startingGlobalIndices[dim - 1]
            + glFineNodesPerDir[dim - 1] - 1;
        }
        colRange[dim - 1] = finishingColIndices[dim - 1] - startingColIndices[dim - 1] + 1;
        colMinGID += startingColIndices[dim - 1]*dimStride[dim - 1];
      }
    }
    ghostColGIDs.resize(colRange[0]*colRange[1]*colRange[2]*BlkSize);
    for(LO k = 0; k < colRange[2]; ++k) {
      for(LO j = 0; j < colRange[1]; ++j) {
        for(LO i = 0; i < colRange[0]; ++i) {
          for(LO l = 0; l < BlkSize; ++l) {
            ghostColGIDs[(k*colRange[1]*colRange[0] + j*colRange[0] + i)*BlkSize + l] = colMinGID
              + (k*gFineNodesPerDir[1]*gFineNodesPerDir[0] + j*gFineNodesPerDir[0] + i)*BlkSize + l;
          }
        }
      }
    }

    RCP<const Map> ghostedRowMap = Xpetra::MapFactory<LO,GO,NO>::Build(A->getRowMap()->lib(),
                                           Teuchos::OrdinalTraits<Xpetra::global_size_t>::invalid(),
                                           ghostRowGIDs(),
                                           A->getRowMap()->getIndexBase(),
                                           A->getRowMap()->getComm());
    RCP<const Map> ghostedColMap = Xpetra::MapFactory<LO,GO,NO>::Build(A->getRowMap()->lib(),
                                           Teuchos::OrdinalTraits<Xpetra::global_size_t>::invalid(),
                                           ghostColGIDs(),
                                           A->getRowMap()->getIndexBase(),
                                           A->getRowMap()->getComm());
    RCP<const Import> ghostImporter = Xpetra::ImportFactory<LO,GO,NO>::Build(A->getRowMap(),
                                                                             ghostedRowMap);
    RCP<const Matrix> Aghost        = Xpetra::MatrixFactory<SC,LO,GO,NO>::Build(A, *ghostImporter,
                                                                                ghostedRowMap,
                                                                                ghostedRowMap);

    // Create the maps and data structures for the projection matrix
    RCP<const Map> rowMapP    = A->getDomainMap();

    RCP<const Map> domainMapP;

    RCP<const Map> colMapP;

    // At this point we need to create the column map which is a delicate operation.
    // The entries in that map need to be ordered as follows:
    //         1) first owned entries ordered by LID
    //         2) second order the remaining entries by PID
    //         3) entries with the same remote PID are ordered by GID.
    // One piece of good news: lNumCoarseNodes is the number of ownedNodes and lNumGhostNodes
    // is the number of remote nodes. The sorting can be limited to remote nodes
    // as the owned ones are alreaded ordered by LID!

    LO lNumGhostedNodes = ghostedCoarseNodes->GIDs.size();
    {
      std::vector<NodeID> colMapOrdering(lNumGhostedNodes);
      for(LO ind = 0; ind < lNumGhostedNodes; ++ind) {
        colMapOrdering[ind].GID = ghostedCoarseNodes->GIDs[ind];
        if(ghostedCoarseNodes->PIDs[ind] == rowMapP->getComm()->getRank()) {
          colMapOrdering[ind].PID = -1;
        } else {
          colMapOrdering[ind].PID = ghostedCoarseNodes->PIDs[ind];
        }
        colMapOrdering[ind].LID = ghostedCoarseNodes->LIDs[ind];
        colMapOrdering[ind].lexiInd = ind;
      }
      std::sort(colMapOrdering.begin(), colMapOrdering.end(),
                [](NodeID a, NodeID b)->bool{
                  return ( (a.PID < b.PID) || ((a.PID == b.PID) && (a.GID < b.GID)) );
                });

      colGIDs.resize(BlkSize*lNumGhostedNodes);
      for(LO ind = 0; ind < lNumGhostedNodes; ++ind) {
        // Save the permutation calculated to go from Lexicographic indexing to column map indexing
        ghostedCoarseNodes->colInds[colMapOrdering[ind].lexiInd] = ind;
        for(LO dof = 0; dof < BlkSize; ++dof) {
          colGIDs[BlkSize*ind + dof] = BlkSize*colMapOrdering[ind].GID + dof;
        }
      }
      domainMapP = Xpetra::MapFactory<LO,GO,NO>::Build(rowMapP->lib(),
                                                       BlkSize*gNumCoarseNodes,
                                                       colGIDs.view(0,BlkSize*lNumCoarseNodes),
                                                       rowMapP->getIndexBase(),
                                                       rowMapP->getComm());
      colMapP = Xpetra::MapFactory<LO,GO,NO>::Build(rowMapP->lib(),
                                                    Teuchos::OrdinalTraits<Xpetra::global_size_t>::invalid(),
                                                    colGIDs.view(0, colGIDs.size()),
                                                    rowMapP->getIndexBase(),
                                                    rowMapP->getComm());
    } // End of scope for colMapOrdering and colGIDs

    std::vector<size_t> strideInfo(1);
    strideInfo[0] = BlkSize;
    RCP<const Map> stridedDomainMapP = Xpetra::StridedMapFactory<LO,GO,NO>::Build(domainMapP,
                                                                                  strideInfo);

    GO gnnzP = 0;
    LO lnnzP = 0;
    // coarse points have one nnz per row
    gnnzP += gNumCoarseNodes;
    lnnzP += lNumCoarseNodes;
    // add all other points multiplying by 2^numDimensions
    gnnzP += (gNumFineNodes - gNumCoarseNodes)*std::pow(2, numDimensions);
    lnnzP += (lNumFineNodes - lNumCoarseNodes)*std::pow(2, numDimensions);
    // finally multiply by the number of dofs per node
    gnnzP = gnnzP*BlkSize;
    lnnzP = lnnzP*BlkSize;

    // Create the matrix itself using the above maps
    RCP<Matrix> P;
    P = rcp(new CrsMatrixWrap(rowMapP, colMapP, 0, Xpetra::StaticProfile));
    RCP<CrsMatrix> PCrs = rcp_dynamic_cast<CrsMatrixWrap>(P)->getCrsMatrix();

    ArrayRCP<size_t>  iaP;
    ArrayRCP<LO>      jaP;
    ArrayRCP<SC>     valP;

    PCrs->allocateAllValues(lnnzP, iaP, jaP, valP);

    ArrayView<size_t> ia  = iaP();
    ArrayView<LO>     ja  = jaP();
    ArrayView<SC>     val = valP();
    ia[0] = 0;


    LO numCoarseElements = 1;
    Array<LO> lCoarseElementsPerDir(3);
    for(LO dim = 0; dim < numDimensions; ++dim) {
      lCoarseElementsPerDir[dim] = lCoarseNodesPerDir[dim];
      if(ghostInterface[2*dim]) {++lCoarseElementsPerDir[dim];}
      if(!ghostInterface[2*dim+1]) {--lCoarseElementsPerDir[dim];}
      numCoarseElements = numCoarseElements*lCoarseElementsPerDir[dim];
    }

    for(LO dim = numDimensions; dim < 3; ++dim) {
      lCoarseElementsPerDir[dim] = 1;
    }

    // Loop over the coarse elements
    Array<int> elementFlags(3);
    Array<LO> elemInds(3), elementNodesPerDir(3), glElementRefTuple(3);
    Array<LO> glElementRefTupleCG(3), glElementCoarseNodeCG(8);
    const int numCoarseNodesInElement = std::pow(2, numDimensions);
    const int nnzPerCoarseNode = (blockStrategy == "coupled") ? BlkSize : 1;
    const int numRowsPerPoint = BlkSize;
    for(elemInds[2] = 0; elemInds[2] < lCoarseElementsPerDir[2]; ++elemInds[2]) {
      for(elemInds[1] = 0; elemInds[1] < lCoarseElementsPerDir[1]; ++elemInds[1]) {
        for(elemInds[0] = 0; elemInds[0] < lCoarseElementsPerDir[0]; ++elemInds[0]) {
          elementFlags[0] = 0; elementFlags[1] = 0; elementFlags[2] = 0;
          for(int dim = 0; dim < 3; ++dim) {
            // Detect boundary conditions on the element and set corresponding flags.
            if(elemInds[dim] == 0 && elemInds[dim] == lCoarseElementsPerDir[dim] - 1) {
              elementFlags[dim] = boundaryFlags[dim];
            } else if(elemInds[dim] == 0 && (boundaryFlags[dim] == 1 || boundaryFlags[dim] == 3)) {
              elementFlags[dim] += 1;
            } else if((elemInds[dim] == lCoarseElementsPerDir[dim] - 1)
                      && (boundaryFlags[dim] == 2 || boundaryFlags[dim] == 3)) {
              elementFlags[dim] += 2;
            } else {
              elementFlags[dim] = 0;
            }

            // Compute the number of nodes in the current element.
            if(dim < numDimensions) {
              if((elemInds[dim] == lCoarseElementsPerDir[dim])
                 && (gIndices[dim] + lFineNodesPerDir[dim] == gFineNodesPerDir[dim])) {
                elementNodesPerDir[dim] = endRate[dim] + 1;
              } else {
                elementNodesPerDir[dim] = coarseRate[dim] + 1;
              }
            } else {
              elementNodesPerDir[dim] = 1;
            }

            // Get the lowest tuple of the element using the ghosted local coordinate system
            glElementRefTuple[dim]   = elemInds[dim]*coarseRate[dim];
            glElementRefTupleCG[dim] = elemInds[dim];
          }

          // Now get the column map indices corresponding to the dofs associated with the current
          // element's coarse nodes.
          for(typename Array<LO>::size_type elem = 0; elem < glElementCoarseNodeCG.size(); ++elem) {
            glElementCoarseNodeCG[elem]
              = glElementRefTupleCG[2]*glCoarseNodesPerDir[1]*glCoarseNodesPerDir[0]
                 + glElementRefTupleCG[1]*glCoarseNodesPerDir[0] + glElementRefTupleCG[0];
          }
          glElementCoarseNodeCG[4] += glCoarseNodesPerDir[1]*glCoarseNodesPerDir[0];
          glElementCoarseNodeCG[5] += glCoarseNodesPerDir[1]*glCoarseNodesPerDir[0];
          glElementCoarseNodeCG[6] += glCoarseNodesPerDir[1]*glCoarseNodesPerDir[0];
          glElementCoarseNodeCG[7] += glCoarseNodesPerDir[1]*glCoarseNodesPerDir[0];

          glElementCoarseNodeCG[2] += glCoarseNodesPerDir[0];
          glElementCoarseNodeCG[3] += glCoarseNodesPerDir[0];
          glElementCoarseNodeCG[6] += glCoarseNodesPerDir[0];
          glElementCoarseNodeCG[7] += glCoarseNodesPerDir[0];

          glElementCoarseNodeCG[1] += 1;
          glElementCoarseNodeCG[3] += 1;
          glElementCoarseNodeCG[5] += 1;
          glElementCoarseNodeCG[7] += 1;

          LO numNodesInElement = elementNodesPerDir[0]*elementNodesPerDir[1]*elementNodesPerDir[2];
          LO elementOffset = elemInds[2]*coarseRate[2]*glFineNodesPerDir[1]*glFineNodesPerDir[0]
            + elemInds[1]*coarseRate[1]*glFineNodesPerDir[0] + elemInds[0]*coarseRate[0];

          // Compute the element prolongator
          Teuchos::SerialDenseMatrix<LO,SC> Pi, Pf, Pe;
          Array<LO> dofType(numNodesInElement*BlkSize), lDofInd(numNodesInElement*BlkSize);
          //ComputeLocalEntries(Aghost, coarseRate, endRate, BlkSize, elemInds, numDimensions,
          //                    lFineNodesPerDir, ghostInterface, elementFlags, stencilType,
          //                    blockStrategy, elementNodesPerDir, numNodesInElement,
          //                    Pi, Pf, Pe, dofType, lDofInd);

          // Find ghosted LID associated with nodes in the element and eventually which of these
          // nodes are ghosts, this information is used to fill the local prolongator.
          Array<LO> lNodeLIDs(numNodesInElement);
          {
            Array<LO> lNodeTuple(3), nodeInd(3);
            for(nodeInd[2] = 0; nodeInd[2] < elementNodesPerDir[2]; ++nodeInd[2]) {
              for(nodeInd[1] = 0; nodeInd[1] < elementNodesPerDir[1]; ++nodeInd[1]) {
                for(nodeInd[0] = 0; nodeInd[0] < elementNodesPerDir[0]; ++nodeInd[0]) {
                  int stencilLength = 0;
                  if((nodeInd[0] == 0 || nodeInd[0] == elementNodesPerDir[0] - 1) &&
                     (nodeInd[1] == 0 || nodeInd[1] == elementNodesPerDir[1] - 1) &&
                     (nodeInd[2] == 0 || nodeInd[2] == elementNodesPerDir[2] - 1)) {
                    stencilLength = 1;
                  } else {
                    stencilLength = std::pow(2, numDimensions);
                  }
                  LO nodeElementInd = nodeInd[2]*elementNodesPerDir[1]*elementNodesPerDir[1]
                    + nodeInd[1]*elementNodesPerDir[0] + nodeInd[0];
                  for(int dim = 0; dim < 3; ++dim) {
                    lNodeTuple[dim] = glElementRefTuple[dim] - myOffset[dim] + nodeInd[dim];
                  }
                  if(lNodeTuple[0] < 0 || lNodeTuple[1] < 0 || lNodeTuple[2] < 0 ||
                     lNodeTuple[0] > lFineNodesPerDir[0] - 1 ||
                     lNodeTuple[1] > lFineNodesPerDir[1] - 1 ||
                     lNodeTuple[2] > lFineNodesPerDir[2] - 1) {
                    // This flags the ghosts nodes used for prolongator calculation but for which
                    // we do not own the row, hence we won't fill these values on this rank.
                    lNodeLIDs[nodeElementInd] = -1;
                  } else if ((nodeInd[0] == 0 && elemInds[0] !=0) ||
                             (nodeInd[1] == 0 && elemInds[1] !=0) ||
                             (nodeInd[2] == 0 && elemInds[2] !=0)) {
                    // This flags nodes that are owned but common to two coarse elements and that
                    // were already filled by another element, we don't want to fill them twice so
                    // we skip them
                    lNodeLIDs[nodeElementInd] = -2;
                  } else {
                    // The remaining nodes are locally owned and we need to fill the coresponding
                    // rows of the prolongator

                    // First we need to find which row needs to be filled
                    lNodeLIDs[nodeElementInd] = lNodeTuple[2]*lFineNodesPerDir[1]*lFineNodesPerDir[0]
                      + lNodeTuple[1]*lFineNodesPerDir[0] + lNodeTuple[0];

                    // We also compute the row offset using arithmetic to ensure that we can loop
                    // easily over the nodes in a macro-element as well as facilitate on-node
                    // parallelization. The node serial code could be rewritten with two loops over
                    // the local part of the mesh to avoid the costly integer divisions...
                    Array<LO> refCoarsePointTuple(3);
                    for(int dim = 2; dim > -1; --dim) {
                      if(dim == 0) {
                        refCoarsePointTuple[dim] = (lNodeTuple[dim] + myOffset[dim]) / coarseRate[dim];
                        if(myOffset[dim] == 0) {
                          ++refCoarsePointTuple[dim];
                        }
                      } else {
                        refCoarsePointTuple[dim] =
                          std::ceil(static_cast<double>(lNodeTuple[dim] + myOffset[dim])
                                    / coarseRate[dim]);
                      }
                      if((lNodeTuple[dim] + myOffset[dim]) % coarseRate[dim] > 0) {break;}
                    }
                    const LO numCoarsePoints = refCoarsePointTuple[0]
                      + refCoarsePointTuple[1]*lCoarseNodesPerDir[0]
                      + refCoarsePointTuple[2]*lCoarseNodesPerDir[1]*lCoarseNodesPerDir[0];
                    const LO numFinePoints = lNodeLIDs[nodeElementInd] + 1;

                    // The below formula computes the rowPtr for row 'n+BlkSize' and we are about to
                    // fill row 'n' to 'n+BlkSize'.
                    size_t rowPtr = (numFinePoints - numCoarsePoints)*numRowsPerPoint
                      *numCoarseNodesInElement*nnzPerCoarseNode + numCoarsePoints*numRowsPerPoint;
                    if(dofType[nodeElementInd*BlkSize] == 0) {
                      // Check if current node is a coarse point
                      rowPtr = rowPtr - numRowsPerPoint;
                    } else {
                      rowPtr = rowPtr - numRowsPerPoint*numCoarseNodesInElement*nnzPerCoarseNode;
                    }

                    for(int dof = 0; dof < BlkSize; ++dof) {

                      // Now we loop over the stencil and fill the column indices and row values
                      int cornerInd = 0;
                      switch(dofType[nodeElementInd*BlkSize + dof]) {
                      case 0: // Corner node
                        if(nodeInd[2] == elementNodesPerDir[2] - 1) {cornerInd += 4;}
                        if(nodeInd[1] == elementNodesPerDir[1] - 1) {cornerInd += 2;}
                        if(nodeInd[0] == elementNodesPerDir[0] - 1) {cornerInd += 1;}
                        ia[lNodeLIDs[nodeElementInd]*BlkSize + dof + 1] = rowPtr + dof + 1;
                        ja[rowPtr + dof] = ghostedCoarseNodes->colInds[glElementCoarseNodeCG[cornerInd]]*BlkSize + dof;
                        val[rowPtr + dof] = 1.0;
                        break;

                      case 1: // Edge node
                        ia[lNodeLIDs[nodeElementInd]*BlkSize + dof + 1]
                          = rowPtr + (dof + 1)*numCoarseNodesInElement*nnzPerCoarseNode;
                        for(int ind1 = 0; ind1 < stencilLength; ++ind1) {
                          if(blockStrategy == "coupled") {
                            for(int ind2 = 0; ind2 < BlkSize; ++ind2) {
                              size_t lRowPtr = rowPtr + dof*numCoarseNodesInElement*nnzPerCoarseNode
                                + ind1*BlkSize + ind2;
                              ja[lRowPtr]  = ghostedCoarseNodes->colInds[glElementCoarseNodeCG[ind1]]*BlkSize + ind2;
                              val[lRowPtr] = Pe(lDofInd[nodeElementInd*BlkSize + dof],
                                                ind1*BlkSize + ind2);
                            }
                          } else if(blockStrategy == "uncoupled") {
                            size_t lRowPtr = rowPtr + dof*numCoarseNodesInElement*nnzPerCoarseNode
                              + ind1;
                            ja[rowPtr + dof] = ghostedCoarseNodes->colInds[glElementCoarseNodeCG[ind1]]*BlkSize + dof;
                            val[lRowPtr] = Pe(lDofInd[nodeElementInd*BlkSize + dof],
                                              ind1*BlkSize + dof);
                          }
                        }
                        break;

                      case 2: // Face node
                        ia[lNodeLIDs[nodeElementInd]*BlkSize + dof + 1]
                          = rowPtr + (dof + 1)*numCoarseNodesInElement*nnzPerCoarseNode;
                        for(int ind1 = 0; ind1 < stencilLength; ++ind1) {
                          if(blockStrategy == "coupled") {
                            for(int ind2 = 0; ind2 < BlkSize; ++ind2) {
                              size_t lRowPtr = rowPtr + dof*numCoarseNodesInElement*nnzPerCoarseNode
                                + ind1*BlkSize + ind2;
                              ja [lRowPtr] = ghostedCoarseNodes->colInds[glElementCoarseNodeCG[ind1]]*BlkSize + ind2;
                              val[lRowPtr] = Pf(lDofInd[nodeElementInd*BlkSize + dof],
                                                ind1*BlkSize + ind2);
                            }
                          } else if(blockStrategy == "uncoupled") {
                            size_t lRowPtr = rowPtr + dof*numCoarseNodesInElement*nnzPerCoarseNode
                              + ind1;
                            // ja [lRowPtr] = colGIDs[glElementCoarseNodeCG[ind1]*BlkSize + dof];
                            ja [lRowPtr] = ghostedCoarseNodes->colInds[glElementCoarseNodeCG[ind1]]*BlkSize + dof;
                            val[lRowPtr] = Pf(lDofInd[nodeElementInd*BlkSize + dof],
                                              ind1*BlkSize + dof);
                          }
                        }
                        break;

                      case 3: // Interior node
                        ia[lNodeLIDs[nodeElementInd]*BlkSize + dof + 1]
                          = rowPtr + (dof + 1)*numCoarseNodesInElement*nnzPerCoarseNode;
                        for(int ind1 = 0; ind1 < stencilLength; ++ind1) {
                          if(blockStrategy == "coupled") {
                            for(int ind2 = 0; ind2 < BlkSize; ++ind2) {
                              size_t lRowPtr = rowPtr + dof*numCoarseNodesInElement*nnzPerCoarseNode
                                + ind1*BlkSize + ind2;
                              ja [lRowPtr] = ghostedCoarseNodes->colInds[glElementCoarseNodeCG[ind1]]*BlkSize + ind2;
                              val[lRowPtr] = Pi(lDofInd[nodeElementInd*BlkSize + dof],
                                                ind1*BlkSize + ind2);
                            }
                          } else if(blockStrategy == "uncoupled") {
                            size_t lRowPtr = rowPtr + dof*numCoarseNodesInElement*nnzPerCoarseNode
                              + ind1;
                            ja [lRowPtr] = ghostedCoarseNodes->colInds[glElementCoarseNodeCG[ind1]]*BlkSize + dof;
                            val[lRowPtr] = Pi(lDofInd[nodeElementInd*BlkSize + dof],
                                              ind1*BlkSize + dof);
                          }
                        }
                        break;
                      }
                    }
                  }
                }
              }
            }
          } // End of scopt for lNodeTuple and nodeInd
        }
      }
    }

    // Sort all row's column indicies and entries by LID
    Xpetra::CrsMatrixUtils<SC,LO,GO,NO>::sortCrsEntries(ia, ja, val, rowMapP->lib());

    // Set the values of the prolongation operators into the CrsMatrix P and call FillComplete
    PCrs->setAllValues(iaP, jaP, valP);
    PCrs->expertStaticFillComplete(domainMapP,rowMapP);

    // set StridingInformation of P
    if (A->IsView("stridedMaps") == true) {
      P->CreateView("stridedMaps", A->getRowMap("stridedMaps"), stridedDomainMapP);
    } else {
      P->CreateView("stridedMaps", P->getRangeMap(), stridedDomainMapP);
    }

    // store the transfer operator and node coordinates on coarse level
    Set(coarseLevel, "P", P);
    Set(coarseLevel, "coarseCoordinates", coarseCoordinates);
    Set<Array<GO> >(coarseLevel, "gCoarseNodesPerDim", gCoarseNodesPerDir);
    Set<Array<LO> >(coarseLevel, "lCoarseNodesPerDim", lCoarseNodesPerDir);

  }

  template <class Scalar, class LocalOrdinal, class GlobalOrdinal, class Node>
  void BlackBoxPFactory<Scalar, LocalOrdinal, GlobalOrdinal, Node>::
  GenerateCoarseInfo(const Array<LO> coarseRate, const Array<GO> gFineNodesPerDir,
                     const RCP<CrsGraph> prolongatorGraph, const Array<LO> lFineNodesPerDir, 
                     const LO BlkSize, const LO numDimensions, Array<LO> &endRate,
                     Array<LO>& myOffset, Array<GO>& gCoarseNodesPerDir, 
                     Array<LO>& lCoarseNodesPerDir, Array<int>& boundaryFlags, Array<GO>& gIndices) const {
    // Not sure the best way to get this? 
    GO minGlobalIndex = prolongatorGraph->getRowMap()->getMinGlobalIndex();
    {
      GO tmp;
      gIndices[2] = minGlobalIndex / (gFineNodesPerDir[1]*gFineNodesPerDir[0]);
      tmp         = minGlobalIndex % (gFineNodesPerDir[1]*gFineNodesPerDir[0]);
      gIndices[1] = tmp / gFineNodesPerDir[0];
      gIndices[0] = tmp % gFineNodesPerDir[0];
      
      myOffset[2] = gIndices[2] % coarseRate[2];
      myOffset[1] = gIndices[1] % coarseRate[1];
      myOffset[0] = gIndices[0] % coarseRate[0];
    }

    for(int dim = 0; dim < numDimensions; ++dim) {
      if(gIndices[dim] == 0) {
        boundaryFlags[dim] += 1;
      }
      if(gIndices[dim] + lFineNodesPerDir[dim] == gFineNodesPerDir[dim]) {
        boundaryFlags[dim] += 2;
      }
    }

    // Check whether ghost nodes are needed in each direction
    //for(LO i=0; i < numDimensions; ++i) {
    //  if((gIndices[i] != 0) && (gIndices[i] % coarseRate[i] > 0)) {
    //    ghostInterface[2*i] = true;
    //  }
    //  if(((gIndices[i] + lFineNodesPerDir[i]) != gFineNodesPerDir[i])
    //     && ((gIndices[i] + lFineNodesPerDir[i] - 1) % coarseRate[i] > 0)) {
    //    ghostInterface[2*i + 1] = true;
    //  }
    //}

    for(LO i = 0; i < 3; ++i) {
      if(i < numDimensions) {
        lCoarseNodesPerDir[i] = (lFineNodesPerDir[i] + myOffset[i] - 1) / coarseRate[i];
        if(myOffset[i] == 0) { ++lCoarseNodesPerDir[i]; }
        gCoarseNodesPerDir[i] = (gFineNodesPerDir[i] - 1) / coarseRate[i];
        endRate[i]            = (gFineNodesPerDir[i] - 1) % coarseRate[i];
        if(endRate[i] == 0) {
          ++gCoarseNodesPerDir[i];
          endRate[i] = coarseRate[i];
        }
      } else {
        // Most quantities need to be set to 1 for extra dimensions
        // this is rather logical, an x-y plane is like a single layer
        // of nodes in the z direction...
        gCoarseNodesPerDir[i] = 1;
        lCoarseNodesPerDir[i] = 1;
        endRate[i]            = 1;
      }
    }
  }

  template <class Scalar, class LocalOrdinal, class GlobalOrdinal, class Node>
  void BlackBoxPFactory<Scalar, LocalOrdinal, GlobalOrdinal, Node>::
  GetGeometricData(RCP<Xpetra::MultiVector<double,LO,GO,NO> >& coordinates,
                   const Array<LO> coarseRate, const Array<GO> gFineNodesPerDir,
                   const Array<LO> lFineNodesPerDir, const LO BlkSize, Array<GO>& gIndices,
                   Array<LO>& myOffset, Array<bool>& ghostInterface, Array<LO>& endRate,
                   Array<GO>& gCoarseNodesPerDir, Array<LO>& lCoarseNodesPerDir,
                   Array<LO>& glCoarseNodesPerDir, Array<GO>& ghostGIDs, Array<GO>& coarseNodesGIDs,
                   Array<GO>& colGIDs, GO& gNumCoarseNodes, LO& lNumCoarseNodes,
                   ArrayRCP<Array<double> > coarseNodes, Array<int>& boundaryFlags,
                   RCP<NodesIDs> ghostedCoarseNodes) const {
    // This function is extracting the geometric information from the coordinates
    // and creates the necessary data/formatting to perform locally the calculation
    // of the pronlongator.
    //
    // inputs:

    RCP<const Map> coordinatesMap = coordinates->getMap();
    LO numDimensions  = coordinates->getNumVectors();

    // Using the coarsening rate and the fine level data,
    // compute coarse level data

    //                              Phase 1                               //
    // ------------------------------------------------------------------ //
    // We first start by finding small informations on the mesh such as   //
    // the number of coarse nodes (local and global) and the number of    //
    // ghost nodes / the end rate of coarsening.                          //
    // ------------------------------------------------------------------ //
    GO minGlobalIndex = coordinatesMap->getMinGlobalIndex();
    {
      GO tmp;
      gIndices[2] = minGlobalIndex / (gFineNodesPerDir[1]*gFineNodesPerDir[0]);
      tmp         = minGlobalIndex % (gFineNodesPerDir[1]*gFineNodesPerDir[0]);
      gIndices[1] = tmp / gFineNodesPerDir[0];
      gIndices[0] = tmp % gFineNodesPerDir[0];

      myOffset[2] = gIndices[2] % coarseRate[2];
      myOffset[1] = gIndices[1] % coarseRate[1];
      myOffset[0] = gIndices[0] % coarseRate[0];
    }

    for(int dim = 0; dim < 3; ++dim) {
      if(gIndices[dim] == 0) {
        boundaryFlags[dim] += 1;
      }
      if(gIndices[dim] + lFineNodesPerDir[dim] == gFineNodesPerDir[dim]) {
        boundaryFlags[dim] += 2;
      }
    }

    // Check whether ghost nodes are needed in each direction
    for(LO i=0; i < numDimensions; ++i) {
      if((gIndices[i] != 0) && (gIndices[i] % coarseRate[i] > 0)) {
        ghostInterface[2*i] = true;
      }
      if(((gIndices[i] + lFineNodesPerDir[i]) != gFineNodesPerDir[i])
         && ((gIndices[i] + lFineNodesPerDir[i] - 1) % coarseRate[i] > 0)) {
        ghostInterface[2*i + 1] = true;
      }
    }

    for(LO i = 0; i < 3; ++i) {
      if(i < numDimensions) {
        lCoarseNodesPerDir[i] = (lFineNodesPerDir[i] + myOffset[i] - 1) / coarseRate[i];
        if(myOffset[i] == 0) { ++lCoarseNodesPerDir[i]; }
        gCoarseNodesPerDir[i] = (gFineNodesPerDir[i] - 1) / coarseRate[i];
        endRate[i]            = (gFineNodesPerDir[i] - 1) % coarseRate[i];
        if(endRate[i] == 0) {
          ++gCoarseNodesPerDir[i];
          endRate[i] = coarseRate[i];
        }
      } else {
        // Most quantities need to be set to 1 for extra dimensions
        // this is rather logical, an x-y plane is like a single layer
        // of nodes in the z direction...
        gCoarseNodesPerDir[i] = 1;
        lCoarseNodesPerDir[i] = 1;
        endRate[i]            = 1;
      }
    }

    gNumCoarseNodes = gCoarseNodesPerDir[0]*gCoarseNodesPerDir[1]*gCoarseNodesPerDir[2];
    lNumCoarseNodes = lCoarseNodesPerDir[0]*lCoarseNodesPerDir[1]*lCoarseNodesPerDir[2];

    // For each direction, determine how many ghost points are required.
    LO lNumGhostNodes = 0;
    Array<GO> startGhostedCoarseNode(3);
    {
      const int complementaryIndices[3][2] = {{1,2}, {0,2}, {0,1}};
      LO tmp = 0;
      for(LO i = 0; i < 3; ++i) {
        // The first branch of this if-statement will be used if the rank contains only one layer
        // of nodes in direction i, that layer must also coincide with the boundary of the mesh
        // and coarseRate[i] == endRate[i]...
        if((gIndices[i] == gFineNodesPerDir[i] - 1) && (gIndices[i] % coarseRate[i] == 0)) {
          startGhostedCoarseNode[i] = gIndices[i] / coarseRate[i] - 1;
        } else {
          startGhostedCoarseNode[i] = gIndices[i] / coarseRate[i];
        }
        // First we load the number of locally owned coarse nodes
        glCoarseNodesPerDir[i] = lCoarseNodesPerDir[i];

        // Check whether a face in direction i needs ghost nodes
        if(ghostInterface[2*i] || ghostInterface[2*i+1]) {
          ++glCoarseNodesPerDir[i];
          if(i == 0) {tmp = lCoarseNodesPerDir[1]*lCoarseNodesPerDir[2];}
          if(i == 1) {tmp = lCoarseNodesPerDir[0]*lCoarseNodesPerDir[2];}
          if(i == 2) {tmp = lCoarseNodesPerDir[0]*lCoarseNodesPerDir[1];}
        }
        // If both faces in direction i need nodes, double the number of ghost nodes
        if(ghostInterface[2*i] && ghostInterface[2*i+1]) {
          ++glCoarseNodesPerDir[i];
          tmp = 2*tmp;
        }
        lNumGhostNodes += tmp;

        // The corners and edges need to be checked in 2D / 3D to add more ghosts nodes
        for(LO j = 0; j < 2; ++j) {
          for(LO k = 0; k < 2; ++k) {
            // Check if two adjoining faces need ghost nodes and then add their common edge
            if(ghostInterface[2*complementaryIndices[i][0]+j]
               && ghostInterface[2*complementaryIndices[i][1]+k]) {
              lNumGhostNodes += lCoarseNodesPerDir[i];
              // Add corners if three adjoining faces need ghost nodes,
              // but add them only once! Hence when i == 0.
              if(ghostInterface[2*i] && (i == 0)) { lNumGhostNodes += 1; }
              if(ghostInterface[2*i+1] && (i == 0)) { lNumGhostNodes += 1; }
            }
          }
        }
        tmp = 0;
      }
    } // end of scope for tmp and complementaryIndices

    const LO lNumGhostedNodes = glCoarseNodesPerDir[0]*glCoarseNodesPerDir[1]
      *glCoarseNodesPerDir[2];
    ghostedCoarseNodes->PIDs.resize(lNumGhostedNodes);
    ghostedCoarseNodes->LIDs.resize(lNumGhostedNodes);
    ghostedCoarseNodes->GIDs.resize(lNumGhostedNodes);
    ghostedCoarseNodes->coarseGIDs.resize(lNumGhostedNodes);
    ghostedCoarseNodes->colInds.resize(lNumGhostedNodes);

    // We loop over all ghosted coarse nodes by increasing global lexicographic order
    Array<LO> coarseNodeCoarseIndices(3), coarseNodeFineIndices(3), ijk(3);
    LO currentIndex = -1;
    for(ijk[2] = 0; ijk[2] < glCoarseNodesPerDir[2]; ++ijk[2]) {
      for(ijk[1] = 0; ijk[1] < glCoarseNodesPerDir[1]; ++ijk[1]) {
        for(ijk[0] = 0; ijk[0] < glCoarseNodesPerDir[0]; ++ijk[0]) {
          currentIndex = ijk[2]*glCoarseNodesPerDir[1]*glCoarseNodesPerDir[0]
            + ijk[1]*glCoarseNodesPerDir[0] + ijk[0];
          coarseNodeCoarseIndices[0] = startGhostedCoarseNode[0] + ijk[0];
          coarseNodeFineIndices[0] = coarseNodeCoarseIndices[0]*coarseRate[0];
          if(coarseNodeFineIndices[0] > gFineNodesPerDir[0] - 1) {
            coarseNodeFineIndices[0] = gFineNodesPerDir[0] - 1;
          }
          coarseNodeCoarseIndices[1] = startGhostedCoarseNode[1] + ijk[1];
          coarseNodeFineIndices[1] = coarseNodeCoarseIndices[1]*coarseRate[1];
          if(coarseNodeFineIndices[1] > gFineNodesPerDir[1] - 1) {
            coarseNodeFineIndices[1] = gFineNodesPerDir[1] - 1;
          }
          coarseNodeCoarseIndices[2] = startGhostedCoarseNode[2] + ijk[2];
          coarseNodeFineIndices[2] = coarseNodeCoarseIndices[2]*coarseRate[2];
          if(coarseNodeFineIndices[2] > gFineNodesPerDir[2] - 1) {
            coarseNodeFineIndices[2] = gFineNodesPerDir[2] - 1;
          }
          GO myGID = 0, myCoarseGID = -1;
          GO factor[3] = {};
          factor[2] = gFineNodesPerDir[1]*gFineNodesPerDir[0];
          factor[1] = gFineNodesPerDir[0];
          factor[0] = 1;
          for(int dim = 0; dim < 3; ++dim) {
            if(dim < numDimensions) {
              if(gIndices[dim] - myOffset[dim] + ijk[dim]*coarseRate[dim]
                 < gFineNodesPerDir[dim] - 1) {
                myGID += (gIndices[dim] - myOffset[dim]
                          + ijk[dim]*coarseRate[dim])*factor[dim];
              } else {
                myGID += (gIndices[dim] - myOffset[dim]
                          + (ijk[dim] - 1)*coarseRate[dim] + endRate[dim])*factor[dim];
              }
            }
          }
          myCoarseGID = coarseNodeCoarseIndices[0]
            + coarseNodeCoarseIndices[1]*gCoarseNodesPerDir[0]
            + coarseNodeCoarseIndices[2]*gCoarseNodesPerDir[1]*gCoarseNodesPerDir[0];
          ghostedCoarseNodes->GIDs[currentIndex] = myGID;
          ghostedCoarseNodes->coarseGIDs[currentIndex] = myCoarseGID;
        }
      }
    }
    coordinatesMap->getRemoteIndexList(ghostedCoarseNodes->GIDs(),
                                       ghostedCoarseNodes->PIDs(),
                                       ghostedCoarseNodes->LIDs());

    //                              Phase 2                               //
    // ------------------------------------------------------------------ //
    // Build a list of GIDs to import the required ghost nodes.           //
    // The ordering of the ghosts nodes will be as natural as possible,   //
    // i.e. it should follow the GID ordering of the mesh.                //
    // ------------------------------------------------------------------ //

    // Saddly we have to more or less redo what was just done to figure out the value of
    // lNumGhostNodes, there might be some optimization possibility here...
    ghostGIDs.resize(lNumGhostNodes);
    LO countGhosts = 0;
    // Get the GID of the first point on the current partition.
    GO startingGID = minGlobalIndex;
    Array<GO> startingIndices(3);
    // We still want ghost nodes even if have with a 0 offset,
    // except when we are on a boundary
    if(ghostInterface[4] && (myOffset[2] == 0)) {
      if(gIndices[2] + coarseRate[2] > gFineNodesPerDir[2]) {
        startingGID -= endRate[2]*gFineNodesPerDir[1]*gFineNodesPerDir[0];
      } else {
        startingGID -= coarseRate[2]*gFineNodesPerDir[1]*gFineNodesPerDir[0];
      }
    } else {
      startingGID -= myOffset[2]*gFineNodesPerDir[1]*gFineNodesPerDir[0];
    }
    if(ghostInterface[2] && (myOffset[1] == 0)) {
      if(gIndices[1] + coarseRate[1] > gFineNodesPerDir[1]) {
        startingGID -= endRate[1]*gFineNodesPerDir[0];
      } else {
        startingGID -= coarseRate[1]*gFineNodesPerDir[0];
      }
    } else {
      startingGID -= myOffset[1]*gFineNodesPerDir[0];
    }
    if(ghostInterface[0] && (myOffset[0] == 0)) {
      if(gIndices[0] + coarseRate[0] > gFineNodesPerDir[0]) {
        startingGID -= endRate[0];
      } else {
        startingGID -= coarseRate[0];
      }
    } else {
      startingGID -= myOffset[0];
    }

    { // scope for tmp
      GO tmp;
      startingIndices[2] = startingGID / (gFineNodesPerDir[1]*gFineNodesPerDir[0]);
      tmp = startingGID % (gFineNodesPerDir[1]*gFineNodesPerDir[0]);
      startingIndices[1] = tmp / gFineNodesPerDir[0];
      startingIndices[0] = tmp % gFineNodesPerDir[0];
    }

    GO ghostOffset[3] = {0, 0, 0};
    LO lengthZero  = lCoarseNodesPerDir[0];
    LO lengthOne   = lCoarseNodesPerDir[1];
    LO lengthTwo   = lCoarseNodesPerDir[2];
    if(ghostInterface[0]) {++lengthZero;}
    if(ghostInterface[1]) {++lengthZero;}
    if(ghostInterface[2]) {++lengthOne;}
    if(ghostInterface[3]) {++lengthOne;}
    if(ghostInterface[4]) {++lengthTwo;}
    if(ghostInterface[5]) {++lengthTwo;}

    // First check the bottom face as it will have the lowest GIDs
    if(ghostInterface[4]) {
      ghostOffset[2] = startingGID;
      for(LO j = 0; j < lengthOne; ++j) {
        if( (j == lengthOne-1)
            && (startingIndices[1] + j*coarseRate[1] + 1 > gFineNodesPerDir[1]) ) {
          ghostOffset[1] = ((j-1)*coarseRate[1] + endRate[1])*gFineNodesPerDir[0];
        } else {
          ghostOffset[1] = j*coarseRate[1]*gFineNodesPerDir[0];
        }
        for(LO k = 0; k < lengthZero; ++k) {
          if( (k == lengthZero-1)
              && (startingIndices[0] + k*coarseRate[0] + 1 > gFineNodesPerDir[0]) ) {
            ghostOffset[0] = (k-1)*coarseRate[0] + endRate[0];
          } else {
            ghostOffset[0] = k*coarseRate[0];
          }
          // If the partition includes a changed rate at the edge, ghost nodes need to be picked
          // carefully.
          // This if statement is repeated each time a ghost node is selected.
          ghostGIDs[countGhosts] = ghostOffset[2] + ghostOffset[1] + ghostOffset[0];
          ++countGhosts;
        }
      }
    }

    // Sweep over the lCoarseNodesPerDir[2] coarse layers in direction 2 and gather necessary ghost
    // nodes located on these layers.
    for(LO i = 0; i < lengthTwo; ++i) {
      // Exclude the cases where ghost nodes exists on the faces in directions 2, these faces are
      // swept seperatly for efficiency.
      if( !((i == lengthTwo-1) && ghostInterface[5]) && !((i == 0) && ghostInterface[4]) ) {
        // Set the ghostOffset in direction 2 taking into account a possible endRate different
        // from the regular coarseRate.
        if( (i == lengthTwo-1) && !ghostInterface[5] ) {
          ghostOffset[2] = startingGID + ((i-1)*coarseRate[2] + endRate[2])
            *gFineNodesPerDir[1]*gFineNodesPerDir[0];
        } else {
          ghostOffset[2] = startingGID + i*coarseRate[2]*gFineNodesPerDir[1]*gFineNodesPerDir[0];
        }
        for(LO j = 0; j < lengthOne; ++j) {
          if( (j == 0) && ghostInterface[2] ) {
            for(LO k = 0; k < lengthZero; ++k) {
              if( (k == lengthZero-1)
                  && (startingIndices[0] + k*coarseRate[0] + 1 > gFineNodesPerDir[0]) ) {
                if(k == 0) {
                  ghostOffset[0] = endRate[0];
                } else {
                  ghostOffset[0] = (k-1)*coarseRate[0] + endRate[0];
                }
              } else {
                ghostOffset[0] = k*coarseRate[0];
              }
              // In this case j == 0 so ghostOffset[1] is zero and can be ignored
              ghostGIDs[countGhosts] = ghostOffset[2] + ghostOffset[0];
              ++countGhosts;
            }
          } else if( (j == lengthOne-1) && ghostInterface[3] ) {
            // Set the ghostOffset in direction 1 taking into account a possible endRate different
            // from the regular coarseRate.
            if( (j == lengthOne-1)
                && (startingIndices[1] + j*coarseRate[1] + 1 > gFineNodesPerDir[1]) ) {
              ghostOffset[1] = ((j-1)*coarseRate[1] + endRate[1])*gFineNodesPerDir[0];
            } else {
              ghostOffset[1] = j*coarseRate[1]*gFineNodesPerDir[0];
            }
            for(LO k = 0; k < lengthZero; ++k) {
              if( (k == lengthZero-1)
                  && (startingIndices[0] + k*coarseRate[0] + 1 > gFineNodesPerDir[0]) ) {
                ghostOffset[0] = (k-1)*coarseRate[0] + endRate[0];
              } else {
                ghostOffset[0] = k*coarseRate[0];
              }
              ghostGIDs[countGhosts] = ghostOffset[2] + ghostOffset[1] + ghostOffset[0];
              ++countGhosts;
            }
          } else {
            // Set ghostOffset[1] for side faces sweep
            if( (j == lengthOne-1)
                && (startingIndices[1] + j*coarseRate[1] + 1 > gFineNodesPerDir[1]) ) {
              ghostOffset[1] = ( (j-1)*coarseRate[1] + endRate[1] )*gFineNodesPerDir[0];
            } else {
              ghostOffset[1] = j*coarseRate[1]*gFineNodesPerDir[0];
            }

            // Set ghostOffset[0], ghostGIDs and countGhosts
            if(ghostInterface[0]) { // In that case ghostOffset[0]==0, so we can ignore it
              ghostGIDs[countGhosts] = ghostOffset[2] + ghostOffset[1];
              ++countGhosts;
            }
            if(ghostInterface[1]) { // Grab ghost point at the end of direction 0.
              if( (startingIndices[0] + (lengthZero-1)*coarseRate[0]) > gFineNodesPerDir[0] - 1 ) {
                if(lengthZero > 2) {
                  ghostOffset[0] = (lengthZero-2)*coarseRate[0] + endRate[0];
                } else {
                  ghostOffset[0] = endRate[0];
                }
              } else {
                ghostOffset[0] = (lengthZero-1)*coarseRate[0];
              }
              ghostGIDs[countGhosts] = ghostOffset[2] + ghostOffset[1] + ghostOffset[0];
              ++countGhosts;
            }
          }
        }
      }
    }

    // Finally check the top face
    if(ghostInterface[5]) {
      if( startingIndices[2] + (lengthTwo-1)*coarseRate[2] + 1 > gFineNodesPerDir[2] ) {
        ghostOffset[2] = startingGID
          + ((lengthTwo-2)*coarseRate[2] + endRate[2])*gFineNodesPerDir[1]*gFineNodesPerDir[0];
      } else {
        ghostOffset[2] = startingGID
          + (lengthTwo-1)*coarseRate[2]*gFineNodesPerDir[1]*gFineNodesPerDir[0];
      }
      for(LO j = 0; j < lengthOne; ++j) {
        if( (j == lengthOne-1)
            && (startingIndices[1] + j*coarseRate[1] + 1 > gFineNodesPerDir[1]) ) {
          ghostOffset[1] = ( (j-1)*coarseRate[1] + endRate[1] )*gFineNodesPerDir[0];
        } else {
          ghostOffset[1] = j*coarseRate[1]*gFineNodesPerDir[0];
        }
        for(LO k = 0; k < lengthZero; ++k) {
          if( (k == lengthZero-1)
              && (startingIndices[0] + k*coarseRate[0] + 1 > gFineNodesPerDir[0]) ) {
            ghostOffset[0] = (k-1)*coarseRate[0] + endRate[0];
          } else {
            ghostOffset[0] = k*coarseRate[0];
          }
          ghostGIDs[countGhosts] = ghostOffset[2] + ghostOffset[1] + ghostOffset[0];
          ++countGhosts;
        }
      }
    }

    //                              Phase 3                               //
    // ------------------------------------------------------------------ //
    // Final phase of this function, lists are being built to create the  //
    // column and domain maps of the projection as well as the map and    //
    // arrays for the coarse coordinates multivector.                     //
    // ------------------------------------------------------------------ //

    Array<GO> gCoarseNodesGIDs(lNumCoarseNodes);
    LO currentNode, offset2, offset1, offset0;
    // Find the GIDs of the coarse nodes on the partition.
    for(LO ind2 = 0; ind2 < lCoarseNodesPerDir[2]; ++ind2) {
      if(myOffset[2] == 0) {
        offset2 = startingIndices[2] + myOffset[2];
      } else {
        if(startingIndices[2] + endRate[2] == gFineNodesPerDir[2] - 1) {
          offset2 = startingIndices[2] + endRate[2];
        } else {
          offset2 = startingIndices[2] + coarseRate[2];
        }
      }
      if(offset2 + ind2*coarseRate[2] > gFineNodesPerDir[2] - 1) {
        offset2 += (ind2 - 1)*coarseRate[2] + endRate[2];
      } else {
        offset2 += ind2*coarseRate[2];
      }
      offset2 = offset2*gFineNodesPerDir[1]*gFineNodesPerDir[0];

      for(LO ind1 = 0; ind1 < lCoarseNodesPerDir[1]; ++ind1) {
        if(myOffset[1] == 0) {
          offset1 = startingIndices[1] + myOffset[1];
        } else {
          if(startingIndices[1] + endRate[1] == gFineNodesPerDir[1] - 1) {
            offset1 = startingIndices[1] + endRate[1];
          } else {
            offset1 = startingIndices[1] + coarseRate[1];
          }
        }
        if(offset1 + ind1*coarseRate[1] > gFineNodesPerDir[1] - 1) {
          offset1 += (ind1 - 1)*coarseRate[1] + endRate[1];
        } else {
          offset1 += ind1*coarseRate[1];
        }
        offset1 = offset1*gFineNodesPerDir[0];
        for(LO ind0 = 0; ind0 < lCoarseNodesPerDir[0]; ++ind0) {
          offset0 = startingIndices[0];
          if(myOffset[0] == 0) {
            offset0 += ind0*coarseRate[0];
          } else {
            offset0 += (ind0 + 1)*coarseRate[0];
          }
          if(offset0 > gFineNodesPerDir[0] - 1) {offset0 += endRate[0] - coarseRate[0];}

          currentNode = ind2*lCoarseNodesPerDir[1]*lCoarseNodesPerDir[0]
                      + ind1*lCoarseNodesPerDir[0]
                      + ind0;
          gCoarseNodesGIDs[currentNode] = offset2 + offset1 + offset0;
        }
      }
    }

    // Actual loop over all the coarse/ghost nodes to find their index on the coarse mesh
    // and the corresponding dofs that will need to be added to colMapP.
    colGIDs.resize(BlkSize*(lNumCoarseNodes+lNumGhostNodes));
    coarseNodesGIDs.resize(lNumCoarseNodes);
    for(LO i = 0; i < numDimensions; ++i) {coarseNodes[i].resize(lNumCoarseNodes);}
    GO fineNodesPerCoarseSlab    = coarseRate[2]*gFineNodesPerDir[1]*gFineNodesPerDir[0];
    GO fineNodesEndCoarseSlab    = endRate[2]*gFineNodesPerDir[1]*gFineNodesPerDir[0];
    GO fineNodesPerCoarsePlane   = coarseRate[1]*gFineNodesPerDir[0];
    GO fineNodesEndCoarsePlane   = endRate[1]*gFineNodesPerDir[0];
    GO coarseNodesPerCoarseLayer = gCoarseNodesPerDir[1]*gCoarseNodesPerDir[0];
    GO gCoarseNodeOnCoarseGridGID;
    LO gInd[3], lCol;
    Array<int> ghostPIDs  (lNumGhostNodes);
    Array<LO>  ghostLIDs  (lNumGhostNodes);
    Array<LO>  ghostPermut(lNumGhostNodes);
    for(LO k = 0; k < lNumGhostNodes; ++k) {ghostPermut[k] = k;}
    coordinatesMap->getRemoteIndexList(ghostGIDs, ghostPIDs, ghostLIDs);
    sh_sort_permute(ghostPIDs.begin(),ghostPIDs.end(), ghostPermut.begin(),ghostPermut.end());

    { // scope for tmpInds, tmpVars and tmp.
      GO tmpInds[3], tmpVars[2];
      LO tmp;
      // Loop over the coarse nodes of the partition and add them to colGIDs
      // that will be used to construct the column and domain maps of P as well
      // as to construct the coarse coordinates map.
      // for(LO col = 0; col < lNumCoarseNodes; ++col) { // This should most likely be replaced
      // by loops of lCoarseNodesPerDir[] to simplify arithmetics
      LO col = 0;
      LO firstCoarseNodeInds[3], currentCoarseNode;
      for(LO dim = 0; dim < 3; ++dim) {
        if(myOffset[dim] == 0) {
          firstCoarseNodeInds[dim] = 0;
        } else {
          firstCoarseNodeInds[dim] = coarseRate[dim] - myOffset[dim];
        }
      }
      Array<ArrayRCP<const double> > fineNodes(numDimensions);
      for(LO dim = 0; dim < numDimensions; ++dim) {fineNodes[dim] = coordinates->getData(dim);}
      for(LO k = 0; k < lCoarseNodesPerDir[2]; ++k) {
        for(LO j = 0; j < lCoarseNodesPerDir[1]; ++j) {
          for(LO i = 0; i < lCoarseNodesPerDir[0]; ++i) {
            col = k*lCoarseNodesPerDir[1]*lCoarseNodesPerDir[0] + j*lCoarseNodesPerDir[0] + i;

            // Check for endRate
            currentCoarseNode = 0;
            if(firstCoarseNodeInds[0] + i*coarseRate[0] > lFineNodesPerDir[0] - 1) {
              currentCoarseNode += firstCoarseNodeInds[0] + (i-1)*coarseRate[0] + endRate[0];
            } else {
              currentCoarseNode += firstCoarseNodeInds[0] + i*coarseRate[0];
            }
            if(firstCoarseNodeInds[1] + j*coarseRate[1] > lFineNodesPerDir[1] - 1) {
              currentCoarseNode += (firstCoarseNodeInds[1] + (j-1)*coarseRate[1] + endRate[1])
                *lFineNodesPerDir[0];
            } else {
              currentCoarseNode += (firstCoarseNodeInds[1] + j*coarseRate[1])*lFineNodesPerDir[0];
            }
            if(firstCoarseNodeInds[2] + k*coarseRate[2] > lFineNodesPerDir[2] - 1) {
              currentCoarseNode += (firstCoarseNodeInds[2] + (k-1)*coarseRate[2] + endRate[2])
                *lFineNodesPerDir[1]*lFineNodesPerDir[0];
            } else {
              currentCoarseNode += (firstCoarseNodeInds[2] + k*coarseRate[2])
                *lFineNodesPerDir[1]*lFineNodesPerDir[0];
            }
            // Load coordinates
            for(LO dim = 0; dim < numDimensions; ++dim) {
              coarseNodes[dim][col] = fineNodes[dim][currentCoarseNode];
            }

            if((endRate[2] != coarseRate[2])
               && (gCoarseNodesGIDs[col] > (gCoarseNodesPerDir[2] - 2)*fineNodesPerCoarseSlab
                   + fineNodesEndCoarseSlab - 1)) {
              tmpInds[2] = gCoarseNodesGIDs[col] / fineNodesPerCoarseSlab + 1;
              tmpVars[0] = gCoarseNodesGIDs[col] - (tmpInds[2] - 1)*fineNodesPerCoarseSlab
                - fineNodesEndCoarseSlab;
            } else {
              tmpInds[2] = gCoarseNodesGIDs[col] / fineNodesPerCoarseSlab;
              tmpVars[0] = gCoarseNodesGIDs[col] % fineNodesPerCoarseSlab;
            }
            if((endRate[1] != coarseRate[1])
               && (tmpVars[0] > (gCoarseNodesPerDir[1] - 2)*fineNodesPerCoarsePlane
                   + fineNodesEndCoarsePlane - 1)) {
              tmpInds[1] = tmpVars[0] / fineNodesPerCoarsePlane + 1;
              tmpVars[1] = tmpVars[0] - (tmpInds[1] - 1)*fineNodesPerCoarsePlane
                - fineNodesEndCoarsePlane;
            } else {
              tmpInds[1] = tmpVars[0] / fineNodesPerCoarsePlane;
              tmpVars[1] = tmpVars[0] % fineNodesPerCoarsePlane;
            }
            if(tmpVars[1] == gFineNodesPerDir[0] - 1) {
              tmpInds[0] = gCoarseNodesPerDir[0] - 1;
            } else {
              tmpInds[0] = tmpVars[1] / coarseRate[0];
            }
            gInd[2] = col / (lCoarseNodesPerDir[1]*lCoarseNodesPerDir[0]);
            tmp     = col % (lCoarseNodesPerDir[1]*lCoarseNodesPerDir[0]);
            gInd[1] = tmp / lCoarseNodesPerDir[0];
            gInd[0] = tmp % lCoarseNodesPerDir[0];
            lCol = gInd[2]*(lCoarseNodesPerDir[1]*lCoarseNodesPerDir[0])
              + gInd[1]*lCoarseNodesPerDir[0] + gInd[0];
            gCoarseNodeOnCoarseGridGID = tmpInds[2]*coarseNodesPerCoarseLayer
              + tmpInds[1]*gCoarseNodesPerDir[0] + tmpInds[0];
            coarseNodesGIDs[lCol] = gCoarseNodeOnCoarseGridGID;
            for(LO dof = 0; dof < BlkSize; ++dof) {
              colGIDs[BlkSize*lCol + dof] = BlkSize*gCoarseNodeOnCoarseGridGID + dof;
            }
          }
        }
      }
      // Now loop over the ghost nodes of the partition to add them to colGIDs
      // since they will need to be included in the column map of P
      for(col = lNumCoarseNodes; col < lNumCoarseNodes + lNumGhostNodes; ++col) {
        if((endRate[2] != coarseRate[2])
           && (ghostGIDs[ghostPermut[col - lNumCoarseNodes]] > (gCoarseNodesPerDir[2] - 2)
               *fineNodesPerCoarseSlab + fineNodesEndCoarseSlab - 1)) {
          tmpInds[2] = ghostGIDs[ghostPermut[col - lNumCoarseNodes]] / fineNodesPerCoarseSlab + 1;
          tmpVars[0] = ghostGIDs[ghostPermut[col - lNumCoarseNodes]]
            - (tmpInds[2] - 1)*fineNodesPerCoarseSlab - fineNodesEndCoarseSlab;
        } else {
          tmpInds[2] = ghostGIDs[ghostPermut[col - lNumCoarseNodes]] / fineNodesPerCoarseSlab;
          tmpVars[0] = ghostGIDs[ghostPermut[col - lNumCoarseNodes]] % fineNodesPerCoarseSlab;
        }
        if((endRate[1] != coarseRate[1])
           && (tmpVars[0] > (gCoarseNodesPerDir[1] - 2)*fineNodesPerCoarsePlane
               + fineNodesEndCoarsePlane - 1)) {
          tmpInds[1] = tmpVars[0] / fineNodesPerCoarsePlane + 1;
          tmpVars[1] = tmpVars[0] - (tmpInds[1] - 1)*fineNodesPerCoarsePlane
            - fineNodesEndCoarsePlane;
        } else {
          tmpInds[1] = tmpVars[0] / fineNodesPerCoarsePlane;
          tmpVars[1] = tmpVars[0] % fineNodesPerCoarsePlane;
        }
        if(tmpVars[1] == gFineNodesPerDir[0] - 1) {
          tmpInds[0] = gCoarseNodesPerDir[0] - 1;
        } else {
          tmpInds[0] = tmpVars[1] / coarseRate[0];
        }
        gCoarseNodeOnCoarseGridGID = tmpInds[2]*coarseNodesPerCoarseLayer
          + tmpInds[1]*gCoarseNodesPerDir[0] + tmpInds[0];
        for(LO dof = 0; dof < BlkSize; ++dof) {
          colGIDs[BlkSize*col + dof] = BlkSize*gCoarseNodeOnCoarseGridGID + dof;
        }
      }
    } // End of scope for tmpInds, tmpVars and tmp

  } // GetGeometricData()

  template <class Scalar, class LocalOrdinal, class GlobalOrdinal, class Node>
  void BlackBoxPFactory<Scalar, LocalOrdinal, GlobalOrdinal, Node>::
  ComputeLocalEntries(const RCP<const Matrix>& Aghosted, const Array<LO> coarseRate,
                      const LO BlkSize, const Array<LO> elemInds, const LO numDimensions, const
                      Array<LO> lFineNodesPerDir, const Array<LO> connectivity,
                      const Array<int> elementFlags, const std::string stencilType, const
                      std::string blockStrategy, const Array<LO>
                      elementNodesPerDir, const LO numNodesInElement,
                      Teuchos::SerialDenseMatrix<LO,SC>& Pi,
                      Teuchos::SerialDenseMatrix<LO,SC>& Pf,
                      Teuchos::SerialDenseMatrix<LO,SC>& Pe,
                      Array<LO>& dofType, Array<LO>& lDofInd) const {

    // First extract data from Aghosted and move it to the corresponding dense matrix
    // This step requires to compute the number of nodes (resp dofs) in the current
    // coarse element, then allocate storage for local dense matrices, finally loop
    // over the dofs and extract the corresponding row in Aghosted before dispactching
    // its data to the dense matrices.
    // At the same time we want to compute a mapping from the element indexing to
    // group indexing. The groups are the following: corner, edge, face and interior
    // nodes. We uses these groups to operate on the dense matrices but need to
    // store the nodes in their original order after groupd operations are completed.
    std::cout << "----------------------------------------------------------" << std::endl;
    std::cout << "Entering ComputeLocalEntries" << std::endl;
    std::cout << "----------------------------------------------------------" << std::endl;
    LO numInteriorNodes = 0, numFaceNodes = 0, numEdgeNodes = 0, numCornerNodes = 8;
    numInteriorNodes = (elementNodesPerDir[0] - 2)*(elementNodesPerDir[1] - 2)
      *(elementNodesPerDir[2] - 2);
    numFaceNodes = 2*(elementNodesPerDir[0] - 2)*(elementNodesPerDir[1] - 2)
      + 2*(elementNodesPerDir[0] - 2)*(elementNodesPerDir[2] - 2)
      + 2*(elementNodesPerDir[1] - 2)*(elementNodesPerDir[2] - 2);
    numEdgeNodes = 4*(elementNodesPerDir[0] - 2) + 4*(elementNodesPerDir[1] - 2)
      + 4*(elementNodesPerDir[2] - 2);
    //std::cout << "numInteriorNodes: " << numInteriorNodes << " numFaceNodes: " << numFaceNodes << " numEdgeNodes: " << numEdgeNodes << std::endl;
    // Diagonal blocks
    Teuchos::SerialDenseMatrix<LO,SC> Aii(BlkSize*numInteriorNodes, BlkSize*numInteriorNodes);
    Teuchos::SerialDenseMatrix<LO,SC> Aff(BlkSize*numFaceNodes,     BlkSize*numFaceNodes);
    Teuchos::SerialDenseMatrix<LO,SC> Aee(BlkSize*numEdgeNodes,     BlkSize*numEdgeNodes);
    // Upper triangular blocks
    Teuchos::SerialDenseMatrix<LO,SC> Aif(BlkSize*numInteriorNodes, BlkSize*numFaceNodes);
    Teuchos::SerialDenseMatrix<LO,SC> Aie(BlkSize*numInteriorNodes, BlkSize*numEdgeNodes);
    Teuchos::SerialDenseMatrix<LO,SC> Afe(BlkSize*numFaceNodes,     BlkSize*numEdgeNodes);
    // Coarse nodes "right hand sides" and local prolongators
    Teuchos::SerialDenseMatrix<LO,SC> Aic(BlkSize*numInteriorNodes, BlkSize*numCornerNodes);
    Teuchos::SerialDenseMatrix<LO,SC> Afc(BlkSize*numFaceNodes,     BlkSize*numCornerNodes);
    Teuchos::SerialDenseMatrix<LO,SC> Aec(BlkSize*numEdgeNodes,     BlkSize*numCornerNodes);
    Pi.shape( BlkSize*numInteriorNodes, BlkSize*numCornerNodes);
    Pf.shape( BlkSize*numFaceNodes,     BlkSize*numCornerNodes);
    Pe.shape( BlkSize*numEdgeNodes,     BlkSize*numCornerNodes);

    ArrayView<const LO> rowIndices;
    ArrayView<const SC> rowValues;
    LO idof, iInd, jInd;
    int iType = 0, jType = 0;
    int orientation = -1;
    int collapseFlags[3] = {};
    Array<SC> stencil((std::pow(3,numDimensions))*BlkSize);
    Array<LO> nodeInd(3);
    // Use connectivity data structure to loop over all nodes in an element
    // without doing arithmetic.
    LO countInterior=0, countFace=0, countEdge=0, countCorner =0;
    LO ie, je, ke;
    Array<LO> collapseDir(numNodesInElement*BlkSize);
    for(size_t i = 0; i < connectivity.size(); i++){
      LO nodeIdx = connectivity[i];
      //std::cout << "nodeIdx = " << nodeIdx << std::endl;
      GetIJKfromIndex(nodeIdx, lFineNodesPerDir, nodeInd[0], nodeInd[1], nodeInd[2]);
      for(size_t i = 0; i < numDimensions; ++i) { nodeInd[i] -= elemInds[i];}
      //std::cout << "nodeInd[0]= " << nodeInd[0] << " nodeInd[1] = " << nodeInd[1] << " nodeInd[2] = " << nodeInd[2] << std::endl;
      ie = nodeInd[0]; je = nodeInd[1]; ke = nodeInd[2];
      // Offset back to indexing from 0:elementNodesPerDir
      /******** Initialize lDofInd and dofType ********/
      // Check for corner node
      if((ke == 0 || ke == elementNodesPerDir[2]-1)
         && (je == 0 || je == elementNodesPerDir[1]-1)
         && (ie == 0 || ie == elementNodesPerDir[0]-1)) {
        for(LO dof = 0; dof < BlkSize; ++dof) {
          dofType[BlkSize*(ke*elementNodesPerDir[1]*elementNodesPerDir[0]
                           + je*elementNodesPerDir[0] + ie) + dof] = 0;
          lDofInd[BlkSize*(ke*elementNodesPerDir[1]*elementNodesPerDir[0]
                           + je*elementNodesPerDir[0] + ie) + dof] = BlkSize*countCorner + dof;
          //std::cout << "Corner!"  << std::endl;
        }
        ++countCorner;

      // Check for edge node
      } else if (((ke == 0 || ke == elementNodesPerDir[2]-1)
                  && (je == 0 || je == elementNodesPerDir[1]-1))
                 || ((ke == 0 || ke == elementNodesPerDir[2]-1)
                     && (ie == 0 || ie == elementNodesPerDir[0]-1))
                 || ((je == 0 || je == elementNodesPerDir[1]-1)
                     && (ie == 0 || ie == elementNodesPerDir[0]-1))) {
        for(LO dof = 0; dof < BlkSize; ++dof) {
          dofType[BlkSize*(ke*elementNodesPerDir[1]*elementNodesPerDir[0]
                           + je*elementNodesPerDir[0] + ie) + dof] = 1;
          lDofInd[BlkSize*(ke*elementNodesPerDir[1]*elementNodesPerDir[0]
                           + je*elementNodesPerDir[0] + ie) + dof] = BlkSize*countEdge + dof;
          //std::cout << "Edge!"  << std::endl;
          if((ke == 0 || ke == elementNodesPerDir[2]-1)
             && (je == 0 || je == elementNodesPerDir[1]-1)) {
            collapseDir[BlkSize*(ke*elementNodesPerDir[1]*elementNodesPerDir[0]
                                 + je*elementNodesPerDir[0] + ie) + dof] = 0;
          } else if((ke == 0 || ke == elementNodesPerDir[2]-1)
                    && (ie == 0 || ie == elementNodesPerDir[0]-1)) {
            collapseDir[BlkSize*(ke*elementNodesPerDir[1]*elementNodesPerDir[0]
                                 + je*elementNodesPerDir[0] + ie) + dof] = 1;
          } else if((je == 0 || je == elementNodesPerDir[1]-1
                     ) && (ie == 0 || ie == elementNodesPerDir[0]-1)) {
            collapseDir[BlkSize*(ke*elementNodesPerDir[1]*elementNodesPerDir[0]
                                 + je*elementNodesPerDir[0] + ie) + dof] = 2;
          }
        }
        ++countEdge;

      // Check for face node
      } else if ((ke == 0 || ke == elementNodesPerDir[2]-1)
                 || (je == 0 || je == elementNodesPerDir[1]-1)
                 || (ie == 0 || ie == elementNodesPerDir[0]-1)) {
        for(LO dof = 0; dof < BlkSize; ++dof) {
          dofType[BlkSize*(ke*elementNodesPerDir[1]*elementNodesPerDir[0]
                           + je*elementNodesPerDir[0] + ie) + dof] = 2;
          lDofInd[BlkSize*(ke*elementNodesPerDir[1]*elementNodesPerDir[0]
                           + je*elementNodesPerDir[0] + ie) + dof] = BlkSize*countFace + dof;
          if(ke == 0 || ke == elementNodesPerDir[2]-1) {
            collapseDir[BlkSize*(ke*elementNodesPerDir[1]*elementNodesPerDir[0]
                                 + je*elementNodesPerDir[0] + ie) + dof] = 2;
          } else if(je == 0 || je == elementNodesPerDir[1]-1) {
            collapseDir[BlkSize*(ke*elementNodesPerDir[1]*elementNodesPerDir[0]
                                 + je*elementNodesPerDir[0] + ie) + dof] = 1;
          } else if(ie == 0 || ie == elementNodesPerDir[0]-1) {
            collapseDir[BlkSize*(ke*elementNodesPerDir[1]*elementNodesPerDir[0]
                                 + je*elementNodesPerDir[0] + ie) + dof] = 0;
          }
        }
        //std::cout << "Face!" << std::endl;
        ++countFace;

      // Otherwise it is an interior node
      } else {
        for(LO dof = 0; dof < BlkSize; ++dof) {
          dofType[BlkSize*(ke*elementNodesPerDir[1]*elementNodesPerDir[0]
                           + je*elementNodesPerDir[0] + ie) + dof] = 3;
          lDofInd[BlkSize*(ke*elementNodesPerDir[1]*elementNodesPerDir[0]
                           + je*elementNodesPerDir[0] + ie) + dof] = BlkSize*countInterior +dof;
        //std::cout << "Interior!" << std::endl;
        }
        ++countInterior;
      }
      
      collapseFlags[0] = 0; collapseFlags[1] = 0; collapseFlags[2] = 0;
      if((elementFlags[0] == 1 || elementFlags[0] == 3) && ie == 0) {
        collapseFlags[0] += 1;
      }
      if((elementFlags[0] == 2 || elementFlags[0] == 3) && ie == elementNodesPerDir[0] - 1) {
        collapseFlags[0] += 2;
      }
      if((elementFlags[1] == 1 || elementFlags[1] == 3) && je == 0) {
        collapseFlags[1] += 1;
      }
      if((elementFlags[1] == 2 || elementFlags[1] == 3) && je == elementNodesPerDir[1] - 1) {
        collapseFlags[1] += 2;
      }
      if((elementFlags[2] == 1 || elementFlags[2] == 3) && ke == 0) {
        collapseFlags[2] += 1;
      }
      if((elementFlags[2] == 2 || elementFlags[2] == 3) && ke == elementNodesPerDir[2] - 1) {
        collapseFlags[2] += 2;
      }

      // Based on (ie, je, ke) we detect the type of node we are dealing with
      GetNodeInfo(ie, je, ke, elementNodesPerDir, &iType, iInd, &orientation);
      for(LO dof0 = 0; dof0 < BlkSize; ++dof0) {
        // Compute the dof index for each dof at point (ie, je, ke)
        idof = ((elemInds[2]*coarseRate[2] + ke)*lFineNodesPerDir[1]*lFineNodesPerDir[0]
                + (elemInds[1]*coarseRate[1] + je)*lFineNodesPerDir[0]
                + elemInds[0]*coarseRate[0] + ie)*BlkSize + dof0;
        Aghosted->getLocalRowView(idof, rowIndices, rowValues);
        FormatStencil(BlkSize, ie, je, ke, rowValues, elementNodesPerDir, collapseFlags, stencilType, stencil);
        LO io, jo, ko;
        if(iType == 3) {// interior node, no stencil collapse needed
          for(LO interactingNode = 0; interactingNode < 27; ++interactingNode) {
            // Find (if, jf, kf) the indices associated with the interacting node
            ko = ke + (interactingNode / 9 - 1);
            {
              LO tmp = interactingNode % 9;
              jo = je + (tmp / 3 - 1);
              io = ie + (tmp % 3 - 1);
              int dummy;
              GetNodeInfo(io, jo, ko, elementNodesPerDir, &jType, jInd, &dummy);
            }
            if((io > -1 && io < elementNodesPerDir[0]) &&
               (jo > -1 && jo < elementNodesPerDir[1]) &&
               (ko > -1 && ko < elementNodesPerDir[2])) {
              for(LO dof1 = 0; dof1 < BlkSize; ++dof1) {
                if (jType == 3) {
                  Aii(iInd*BlkSize + dof0, jInd*BlkSize + dof1) =
                    stencil[interactingNode*BlkSize + dof1];
                } else if(jType == 2) {
                  Aif(iInd*BlkSize + dof0, jInd*BlkSize + dof1) =
                    stencil[interactingNode*BlkSize + dof1];
                } else if(jType == 1) {
                  Aie(iInd*BlkSize + dof0, jInd*BlkSize + dof1) =
                    stencil[interactingNode*BlkSize + dof1];
                } else if(jType == 0) {
                  Aic(iInd*BlkSize + dof0, jInd*BlkSize + dof1) =
                    -stencil[interactingNode*BlkSize + dof1];
                }
              }
            }
          }
        } else if(iType == 2) {// Face node, collapse stencil along face normal (*orientation)
          CollapseStencil(2, orientation, collapseFlags, stencil);
          for(LO interactingNode = 0; interactingNode < 27; ++interactingNode) {
            // Find (if, jf, kf) the indices associated with the interacting node
            ko = ke + (interactingNode / 9 - 1);
            {
              LO tmp = interactingNode % 9;
              jo = je + (tmp / 3 - 1);
              io = ie + (tmp % 3 - 1);
              int dummy;
              GetNodeInfo(io, jo, ko, elementNodesPerDir, &jType, jInd, &dummy);
            }
            if((io > -1 && io < elementNodesPerDir[0]) &&
               (jo > -1 && jo < elementNodesPerDir[1]) &&
               (ko > -1 && ko < elementNodesPerDir[2])) {
              for(LO dof1 = 0; dof1 < BlkSize; ++dof1) {
                if(jType == 2) {
                  Aff(iInd*BlkSize + dof0, jInd*BlkSize + dof1) =
                    stencil[interactingNode*BlkSize + dof1];
                } else if(jType == 1) {
                  Afe(iInd*BlkSize + dof0, jInd*BlkSize + dof1) =
                    stencil[interactingNode*BlkSize + dof1];
                } else if(jType == 0) {
                  Afc(iInd*BlkSize + dof0, jInd*BlkSize + dof1) =
                    -stencil[interactingNode*BlkSize + dof1];
                }
              }
            }
          }
        } else if(iType == 1) {// Edge node, collapse stencil perpendicular to edge direction
          CollapseStencil(1, orientation, collapseFlags, stencil);
          for(LO interactingNode = 0; interactingNode < 27; ++interactingNode) {
            // Find (if, jf, kf) the indices associated with the interacting node
            ko = ke + (interactingNode / 9 - 1);
            {
              LO tmp = interactingNode % 9;
              jo = je + (tmp / 3 - 1);
              io = ie + (tmp % 3 - 1);
              int dummy;
              GetNodeInfo(io, jo, ko, elementNodesPerDir, &jType, jInd, &dummy);
            }
            if((io > -1 && io < elementNodesPerDir[0]) &&
               (jo > -1 && jo < elementNodesPerDir[1]) &&
               (ko > -1 && ko < elementNodesPerDir[2])) {
              for(LO dof1 = 0; dof1 < BlkSize; ++dof1) {
                if(jType == 1) {
                  Aee(iInd*BlkSize + dof0, jInd*BlkSize + dof1) =
                    stencil[interactingNode*BlkSize + dof1];
                } else if(jType == 0) {
                  Aec(iInd*BlkSize + dof0, jInd*BlkSize + dof1) =
                    -stencil[interactingNode*BlkSize + dof1];
                }
              } // Check if interacting node is in element or not
            } // Pc is the identity so no need to treat iType == 0
          } // Loop over interacting nodes within a row
        } // Check for current node type
      } // Loop over degrees of freedom associated to a given node
    }

    //std::cout << "countInterior= " << countInterior << " countFace = " << countFace << " countEdge = " << countEdge << " countCorner = "<< countCorner  << std::endl;
    // Compute the projection operators for edge and interior nodes
    //
    //         [P_i] = [A_{ii} & A_{if} & A_{ie}]^{-1} [A_{ic}]
    //         [P_f] = [  0    & A_{ff} & A_{fe}]      [A_{fc}]
    //         [P_e] = [  0    &   0    & A_{ee}]      [A_{ec}]
    //         [P_c] =  I_c
    //
    { // Compute P_e
      // We need to solve for P_e in: A_{ee}*P_e = A_{fc}
      // So we simple do P_e = A_{ee}^{-1)*A_{ec}
      Teuchos::SerialDenseSolver<LO,SC> problem;
      problem.setMatrix(Teuchos::rcp(&Aee, false));
      problem.setVectors(Teuchos::rcp(&Pe, false), Teuchos::rcp(&Aec, false));
      problem.factorWithEquilibration(true);
      problem.solve();
      problem.unequilibrateLHS();
    }

    { // Compute P_f
      // We need to solve for P_f in: A_{ff}*P_f + A_{fe}*P_e = A_{fc}
      // Step one: A_{fc} = 1.0*A_{fc} + (-1.0)*A_{fe}*P_e
      Afc.multiply(Teuchos::NO_TRANS, Teuchos::NO_TRANS, -1.0, Afe, Pe, 1.0);
      // Step two: P_f = A_{ff}^{-1}*A_{fc}
      Teuchos::SerialDenseSolver<LO,SC> problem;
      problem.setMatrix(Teuchos::rcp(&Aff, false));
      problem.setVectors(Teuchos::rcp(&Pf, false), Teuchos::rcp(&Afc, false));
      problem.factorWithEquilibration(true);
      problem.solve();
      problem.unequilibrateLHS();
    }

    { // Compute P_i
      // We need to solve for P_i in: A_{ii}*P_i + A_{if}*P_f + A_{ie}*P_e = A_{ic}
      // Step one: A_{ic} = 1.0*A_{ic} + (-1.0)*A_{ie}*P_e
      Aic.multiply(Teuchos::NO_TRANS, Teuchos::NO_TRANS, -1.0, Aie, Pe, 1.0);
      // Step one: A_{ic} = 1.0*A_{ic} + (-1.0)*A_{if}*P_f
      Aic.multiply(Teuchos::NO_TRANS, Teuchos::NO_TRANS, -1.0, Aif, Pf, 1.0);
      // Step two: P_i = A_{ii}^{-1}*A_{ic}
      Teuchos::SerialDenseSolver<LO,SC> problem;
      problem.setMatrix(Teuchos::rcp(&Aii, false));
      problem.setVectors(Teuchos::rcp(&Pi, false), Teuchos::rcp(&Aic, false));
      problem.factorWithEquilibration(true);
      problem.solve();
      problem.unequilibrateLHS();
    }
  } // ComputeLocalEntries()

  template <class Scalar, class LocalOrdinal, class GlobalOrdinal, class Node>
  void BlackBoxPFactory<Scalar, LocalOrdinal, GlobalOrdinal, Node>::
  CollapseStencil(const int type, const int orientation, const int collapseFlags[3],
                  Array<SC>& stencil) const {

    if(type == 2) {// Face stencil collapse
      // Let's hope things vectorize well inside this if statement
      if(orientation == 0) {
        for(LO i = 0; i < 9; ++i) {
          stencil[3*i + 1] = stencil[3*i] + stencil[3*i + 1] + stencil[3*i + 2];
          stencil[3*i]     = 0;
          stencil[3*i + 2] = 0;
        }
      } else if(orientation == 1) {
        for(LO i = 0; i < 3; ++i) {
          stencil[9*i + 3] = stencil[9*i + 0] + stencil[9*i + 3] + stencil[9*i + 6];
          stencil[9*i + 0] = 0;
          stencil[9*i + 6] = 0;
          stencil[9*i + 4] = stencil[9*i + 1] + stencil[9*i + 4] + stencil[9*i + 7];
          stencil[9*i + 1] = 0;
          stencil[9*i + 7] = 0;
          stencil[9*i + 5] = stencil[9*i + 2] + stencil[9*i + 5] + stencil[9*i + 8];
          stencil[9*i + 2] = 0;
          stencil[9*i + 8] = 0;
        }
      } else if(orientation == 2) {
        for(LO i = 0; i < 9; ++i) {
          stencil[i + 9]  = stencil[i] + stencil[i + 9] + stencil[i + 18];
          stencil[i]      = 0;
          stencil[i + 18] = 0;
        }
      }
    } else if(type == 1) {// Edge stencil collapse
      SC tmp1 = 0, tmp2 = 0, tmp3 = 0;
      if(orientation == 0) {
        for(LO i = 0; i < 9; ++i) {
          tmp1 += stencil[0 + 3*i];
          stencil[0 + 3*i] = 0;
          tmp2 += stencil[1 + 3*i];
          stencil[1 + 3*i] = 0;
          tmp3 += stencil[2 + 3*i];
          stencil[2 + 3*i] = 0;
        }
        stencil[12] = tmp1;
        stencil[13] = tmp2;
        stencil[14] = tmp3;
      } else if(orientation == 1) {
        for(LO i = 0; i < 3; ++i) {
          tmp1 += stencil[0 + i] + stencil[9 + i] + stencil[18 + i];
          stencil[ 0 + i] = 0;
          stencil[ 9 + i] = 0;
          stencil[18 + i] = 0;
          tmp2 += stencil[3 + i] + stencil[12 + i] + stencil[21 + i];
          stencil[ 3 + i] = 0;
          stencil[12 + i] = 0;
          stencil[21 + i] = 0;
          tmp3 += stencil[6 + i] + stencil[15 + i] + stencil[24 + i];
          stencil[ 6 + i] = 0;
          stencil[15 + i] = 0;
          stencil[24 + i] = 0;
        }
        stencil[10] = tmp1;
        stencil[13] = tmp2;
        stencil[16] = tmp3;
      } else if(orientation == 2) {
        for(LO i = 0; i < 9; ++i) {
          tmp1 += stencil[i];
          stencil[i] = 0;
          tmp2 += stencil[i +  9];
          stencil[i +  9] = 0;
          tmp3 += stencil[i + 18];
          stencil[i + 18] = 0;
        }
        stencil[ 4] = tmp1;
        stencil[13] = tmp2;
        stencil[22] = tmp3;
      }
    }
  } // CollapseStencil

  template <class Scalar, class LocalOrdinal, class GlobalOrdinal, class Node>
  void BlackBoxPFactory<Scalar, LocalOrdinal, GlobalOrdinal, Node>::
  FormatStencil(const LO BlkSize, const LO ie, const LO je,  const LO ke, 
                const ArrayView<const SC> rowValues,const Array<LO> elementNodesPerDir,
                const int collapseFlags[3], const std::string stencilType, Array<SC>& stencil)
    const {
    //std::cout << "----------------------------------------------------------" << std::endl;
    //std::cout << "Entering FormatStencil" << std::endl;
    //std::cout << "----------------------------------------------------------" << std::endl;
    if(stencilType == "reduced") {
      Array<int> fullStencilInds(7);
      fullStencilInds[0] =  4; fullStencilInds[1] = 10; fullStencilInds[2] = 12;
      fullStencilInds[3] = 13; fullStencilInds[4] = 14; fullStencilInds[5] = 16;
      fullStencilInds[6] = 22;

      // Create a mask array to automate mesh boundary processing
      Array<int> mask(7);
      int stencilSize = rowValues.size();
      if(collapseFlags[0] + collapseFlags[1] + collapseFlags[2] > 0) {
        if(stencilSize == 1) {
          // The assumption is made that if only one non-zero exists in the row
          // then this represent a Dirichlet BC being enforced.
          // One might want to zero out the corresponding row in the prolongator.
          mask[0] = 1; mask[1] = 1; mask[2] = 1;
          mask[4] = 1; mask[5] = 1; mask[6] = 1;
        } else {
          // Here we are looking at Neumann like BC where only a flux is prescribed
          // and less non-zeros will be present in the corresponding row.
          if(collapseFlags[2] == 1 || collapseFlags[2] == 3) {
            mask[0] = 1;
          }
          if(collapseFlags[2] == 2 || collapseFlags[2] == 3) {
            mask[6] = 1;
          }
          if(collapseFlags[1] == 1 || collapseFlags[1] == 3) {
            mask[1] = 1;
          }
          if(collapseFlags[1] == 2 || collapseFlags[1] == 3) {
            mask[5] = 1;
          }
          if(collapseFlags[0] == 1 || collapseFlags[0] == 3) {
            mask[2] = 1;
          }
          if(collapseFlags[0] == 2 || collapseFlags[0] == 3) {
            mask[4] = 1;
          }
        }
      }

      int offset = 0;
      for(int ind = 0; ind < 7; ++ind) {
        if(mask[ind] == 1) {
          for(int dof = 0; dof < BlkSize; ++dof) {
            stencil[BlkSize*fullStencilInds[ind] + dof] = 0.0;
          }
          ++offset; // The offset is used to stay within rowValues bounds
        } else {
          for(int dof = 0; dof < BlkSize; ++dof) {
            stencil[BlkSize*fullStencilInds[ind] + dof] = rowValues[BlkSize*(ind - offset) + dof];
          }
        }
      }
    } else if(stencilType == "full") {
      // Create a mask array to automate mesh boundary processing
      Array<int> mask(27);
      if(collapseFlags[2] == 1 || collapseFlags[2] == 3) {
        for(int ind = 0; ind < 9; ++ind) {
          mask[ind] = 1;
        }
      }
      if(collapseFlags[2] == 2 || collapseFlags[2] == 3) {
        for(int ind = 0; ind < 9; ++ind) {
          mask[18 + ind] = 1;
        }
      }
      if(collapseFlags[1] == 1 || collapseFlags[1] == 3) {
        for(int ind1 = 0; ind1 < 3; ++ind1) {
          for(int ind2 = 0; ind2 < 3; ++ind2) {
            mask[ind1*9 + ind2] = 1;
          }
        }
      }
      if(collapseFlags[1] == 2 || collapseFlags[1] == 3) {
        for(int ind1 = 0; ind1 < 3; ++ind1) {
          for(int ind2 = 0; ind2 < 3; ++ind2) {
            mask[ind1*9 + ind2 + 6] = 1;
          }
        }
      }
      if(collapseFlags[0] == 1 || collapseFlags[0] == 3) {
        for(int ind = 0; ind < 9; ++ind) {
          mask[3*ind] = 1;
        }
      }
      if(collapseFlags[0] == 2 || collapseFlags[0] == 3) {
        for(int ind = 0; ind < 9; ++ind) {
          mask[3*ind + 2] = 1;
        }
      }

      // Now the stencil is extracted and formated
      int offset = 0;
      for(LO ind = 0; ind < 27; ++ind) {
        if(mask[ind] == 0) {
          for(int dof = 0; dof < BlkSize; ++dof) {
            stencil[BlkSize*ind + dof] = 0.0;
          }
          ++offset; // The offset is used to stay within rowValues bounds
        } else {
          for(int dof = 0; dof < BlkSize; ++dof) {
            stencil[BlkSize*ind + dof] = rowValues[BlkSize*(ind - offset) + dof];
          }
        }
      }
    } // stencilTpye
  } // FormatStencil()

  template <class Scalar, class LocalOrdinal, class GlobalOrdinal, class Node>
  void BlackBoxPFactory<Scalar, LocalOrdinal, GlobalOrdinal, Node>::
  GetIJKfromIndex(const LO index, const Array<LO> lFineNodesPerDir,  LO& ie, LO& je,
                  LO& ke)
  const {
    LO Nx = lFineNodesPerDir[0];
    LO Ny = lFineNodesPerDir[1];
    LO Nz = lFineNodesPerDir[2];
    ie = index % Nx;
    je = ((index - ie)/Nx) % Ny;
    ke = (index - (Nx*je) - ie) / (Nx*Ny);
  }

  template <class Scalar, class LocalOrdinal, class GlobalOrdinal, class Node>
  void BlackBoxPFactory<Scalar, LocalOrdinal, GlobalOrdinal, Node>::
  ExtractFromLocal(const Teuchos::SerialDenseMatrix<LO,SC> Pi,
                   const Teuchos::SerialDenseMatrix<LO,SC> Pf, const
                   Teuchos::SerialDenseMatrix<LO,SC> Pe, LO numNodesInElement,
                   const Array<LO> elementNodesPerDir, const Array<LO>
                   connectivity, const Array<LO> lFineNodesPerDir, const int
                   numDimensions, const Array<LO> coarseRate, const Array<LO> glElementCoarseNodeCG,
                   const Array<LO> glElementRefTuple,
                   const Array<LO> myOffset, const Array<LO> dofType, const Array<LO> lDofInd,
                   const Array<LO> elemInds, const LO BlkSize, const int nnzPerCoarseNode,
                   const RCP<NodesIDs> ghostedCoarseNodes, const std::string blockStrategy,
                   const Array<LO> lCoarseNodesPerDir,
                   ArrayView<size_t>& ia, ArrayView<LO>& ja, ArrayView<SC>& val)
  const {
    std::cout << "----------------------------------------------------------" << std::endl;
    std::cout << "Entering ExtractFromLocal" << std::endl;
    std::cout << "----------------------------------------------------------" << std::endl;
    Array<LO> lNodeLIDs(numNodesInElement);
    Array<LO> lNodeTuple(3), nodeInd(3);
    LO numCoarseNodesInElement = std::pow(2, numDimensions);
    std::cout << "EnodesPerDir[0]= " << elementNodesPerDir[0] << " EnodesPerDir[1]= " << elementNodesPerDir[1] << " EnodesPerDir[2]= " << elementNodesPerDir[2] << std::endl;
    for(size_t i = 0; i < connectivity.size(); i++){
      LO nodeIdx = connectivity[i];
      //std::cout << "nodeIdx = " << nodeIdx << std::endl;
      GetIJKfromIndex(nodeIdx, lFineNodesPerDir, nodeInd[0], nodeInd[1], nodeInd[2]);
      for(size_t i = 0; i < numDimensions; ++i) { nodeInd[i] -= elemInds[i];}
      int stencilLength = 0;
      if((nodeInd[0] == 0 || nodeInd[0] == elementNodesPerDir[0] - 1) &&
         (nodeInd[1] == 0 || nodeInd[1] == elementNodesPerDir[1] - 1) &&
         (nodeInd[2] == 0 || nodeInd[2] == elementNodesPerDir[2] - 1)) {
        stencilLength = 1;
      } else {
        stencilLength = std::pow(2, numDimensions);
      }
      LO nodeElementInd =nodeInd[2]*elementNodesPerDir[1]*elementNodesPerDir[0]
                         + nodeInd[1]*elementNodesPerDir[0] + nodeInd[0];
      for(int dim = 0; dim < 3; ++dim) {
        lNodeTuple[dim] = glElementRefTuple[dim] - myOffset[dim] + nodeInd[dim];
      }
      if(lNodeTuple[0] < 0 || lNodeTuple[1] < 0 || lNodeTuple[2] < 0 ||
         lNodeTuple[0] > lFineNodesPerDir[0] - 1 ||
         lNodeTuple[1] > lFineNodesPerDir[1] - 1 ||
         lNodeTuple[2] > lFineNodesPerDir[2] - 1) {
        // This flags the ghosts nodes used for prolongator calculation but for which
        // we do not own the row, hence we won't fill these values on this rank.
        lNodeLIDs[nodeElementInd] = -1;
      } else if ((nodeInd[0] == 0 && elemInds[0] !=0) ||
                 (nodeInd[1] == 0 && elemInds[1] !=0) ||
                 (nodeInd[2] == 0 && elemInds[2] !=0)) {
        // This flags nodes that are owned but common to two coarse elements and that
        // were already filled by another element, we don't want to fill them twice so
        // we skip them
        lNodeLIDs[nodeElementInd] = -2;
      } else {
        // The remaining nodes are locally owned and we need to fill the coresponding
        // rows of the prolongator

        // First we need to find which row needs to be filled
        lNodeLIDs[nodeElementInd] = lNodeTuple[2]*lFineNodesPerDir[1]*lFineNodesPerDir[0]
          + lNodeTuple[1]*lFineNodesPerDir[0] + lNodeTuple[0];

        // We also compute the row offset using arithmetic to ensure that we can loop
        // easily over the nodes in a macro-element as well as facilitate on-node
        // parallelization. The node serial code could be rewritten with two loops over
        // the local part of the mesh to avoid the costly integer divisions...
        Array<LO> refCoarsePointTuple(3);
        for(int dim = 2; dim > -1; --dim) {
          if(dim == 0) {
            refCoarsePointTuple[dim] = (lNodeTuple[dim] + myOffset[dim]) / coarseRate[dim];
            if(myOffset[dim] == 0) {
              ++refCoarsePointTuple[dim];
            }
          } else {
            refCoarsePointTuple[dim] =
              std::ceil(static_cast<double>(lNodeTuple[dim] + myOffset[dim])
                        / coarseRate[dim]);
          }
          if((lNodeTuple[dim] + myOffset[dim]) % coarseRate[dim] > 0) {break;}
        }
        const LO numCoarsePoints = refCoarsePointTuple[0]
          + refCoarsePointTuple[1]*lCoarseNodesPerDir[0]
          + refCoarsePointTuple[2]*lCoarseNodesPerDir[1]*lCoarseNodesPerDir[0];
        const LO numFinePoints = lNodeLIDs[nodeElementInd] + 1;

        // The below formula computes the rowPtr for row 'n+BlkSize' and we are about to
        // fill row 'n' to 'n+BlkSize'.
        size_t rowPtr = (numFinePoints - numCoarsePoints)*BlkSize
          *numCoarseNodesInElement*nnzPerCoarseNode + numCoarsePoints*BlkSize;
        if(dofType[nodeElementInd*BlkSize] == 0) {
          // Check if current node is a coarse point
          rowPtr = rowPtr - BlkSize;
        } else {
          rowPtr = rowPtr - BlkSize*numCoarseNodesInElement*nnzPerCoarseNode;
        }


        for(int dof = 0; dof < BlkSize; ++dof) {

          // Now we loop over the stencil and fill the column indices and row values
          int cornerInd = 0;
          switch(dofType[nodeElementInd*BlkSize + dof]) {
          case 0: // Corner node
            //std::cout << "corner:" << "nodeElementInd" << nodeElementInd << std::endl;
            if(nodeInd[2] == elementNodesPerDir[2] - 1) {cornerInd += 4;}
            if(nodeInd[1] == elementNodesPerDir[1] - 1) {cornerInd += 2;}
            if(nodeInd[0] == elementNodesPerDir[0] - 1) {cornerInd += 1;}
            ia[lNodeLIDs[nodeElementInd]*BlkSize + dof + 1] = rowPtr + dof + 1;
            
            //ja[rowPtr + dof] = ghostedCoarseNodes->colInds[glElementCoarseNodeCG[cornerInd]]*BlkSize + dof;
            val[rowPtr + dof] = 1.0;
            break;

          case 1: // Edge node
            //std::cout << "edge: nodeElementInd= " << nodeElementInd << " dof " << dof << std::endl;
            ia[lNodeLIDs[nodeElementInd]*BlkSize + dof + 1]
              = rowPtr + (dof + 1)*numCoarseNodesInElement*nnzPerCoarseNode;
            //std::cout <<  "lNodeLIDs[nodeElementInd]*BlkSize + dof + 1]:" << lNodeLIDs[nodeElementInd]*BlkSize + dof + 1<< std::endl;
            for(int ind1 = 0; ind1 < stencilLength; ++ind1) {
              if(blockStrategy == "coupled") {
                for(int ind2 = 0; ind2 < BlkSize; ++ind2) {
                  size_t lRowPtr = rowPtr + dof*numCoarseNodesInElement*nnzPerCoarseNode
                    + ind1*BlkSize + ind2;
                  //std::cout << "lRowPtr: " << lRowPtr << "ja: " << ja << std::endl;
                  //ja[lRowPtr]  = ghostedCoarseNodes->colInds[ind]*BlkSize + ind2;
                  // Ari: Should be dof*BlkSize? Not sure what's going on here
                  //std::cout << "lDofInd[nodeElementInd*BlkSize + dof]:" << lDofInd[nodeElementInd *BlkSize + dof] << std::endl;
                  val[lRowPtr] = Pe(lDofInd[nodeElementInd*BlkSize + dof],
                                    ind1*BlkSize + ind2);
                }
              } else if(blockStrategy == "uncoupled") {
                size_t lRowPtr = rowPtr + dof*numCoarseNodesInElement*nnzPerCoarseNode
                  + ind1;
                //ja[rowPtr + dof] = ghostedCoarseNodes->colInds[glElementCoarseNodeCG[ind1]]*BlkSize + dof;
                val[lRowPtr] = Pe(lDofInd[nodeElementInd*BlkSize + dof],
                                  ind1*BlkSize + dof);
              }
            }
            break;

          case 2: // Face node
            //std::cout << "face: nodeElementInd= " << nodeElementInd << std::endl;
            ia[lNodeLIDs[nodeElementInd]*BlkSize + dof + 1]
              = rowPtr + (dof + 1)*numCoarseNodesInElement*nnzPerCoarseNode;

            for(int ind1 = 0; ind1 < stencilLength; ++ind1) {
              if(blockStrategy == "coupled") {
                for(int ind2 = 0; ind2 < BlkSize; ++ind2) {
                  size_t lRowPtr = rowPtr + dof*numCoarseNodesInElement*nnzPerCoarseNode
                    + ind1*BlkSize + ind2;
                  //ja [lRowPtr] = ghostedCoarseNodes->colInds[glElementCoarseNodeCG[ind1]]*BlkSize + ind2;
                  val[lRowPtr] = Pf(lDofInd[nodeElementInd*BlkSize + dof],
                                    ind1*BlkSize + ind2);
                }
              } else if(blockStrategy == "uncoupled") {
                size_t lRowPtr = rowPtr + dof*numCoarseNodesInElement*nnzPerCoarseNode
                  + ind1;
                // ja [lRowPtr] = colGIDs[glElementCoarseNodeCG[ind1]*BlkSize + dof];
                //ja [lRowPtr] = ghostedCoarseNodes->colInds[glElementCoarseNodeCG[ind1]]*BlkSize + dof;
                val[lRowPtr] = Pf(lDofInd[nodeElementInd*BlkSize + dof],
                                  ind1*BlkSize + dof);
              }
            }
            break;

          case 3: // Interior node
            //std::cout << "interor: nodeElementInd= " << nodeElementInd << std::endl;
            ia[lNodeLIDs[nodeElementInd]*BlkSize + dof + 1]
              = rowPtr + (dof + 1)*numCoarseNodesInElement*nnzPerCoarseNode;
            for(int ind1 = 0; ind1 < stencilLength; ++ind1) {
              if(blockStrategy == "coupled") {
                for(int ind2 = 0; ind2 < BlkSize; ++ind2) {
                  size_t lRowPtr = rowPtr + dof*numCoarseNodesInElement*nnzPerCoarseNode
                    + ind1*BlkSize + ind2;
                  //ja [lRowPtr] = ghostedCoarseNodes->colInds[glElementCoarseNodeCG[ind1]]*BlkSize + ind2;
                  val[lRowPtr] = Pi(lDofInd[nodeElementInd*BlkSize + dof],
                                    ind1*BlkSize + ind2);
                }
              } else if(blockStrategy == "uncoupled") {
                size_t lRowPtr = rowPtr + dof*numCoarseNodesInElement*nnzPerCoarseNode
                  + ind1;
                //ja [lRowPtr] = ghostedCoarseNodes->colInds[glElementCoarseNodeCG[ind1]]*BlkSize + dof;
                val[lRowPtr] = Pi(lDofInd[nodeElementInd*BlkSize + dof],
                                  ind1*BlkSize + dof);
              }
            }
            break;
          }
        }
      }
    }
  }

  template <class Scalar, class LocalOrdinal, class GlobalOrdinal, class Node>
  void BlackBoxPFactory<Scalar, LocalOrdinal, GlobalOrdinal, Node>::
  GetCoordinates(const Array<LO> lFineNodesPerDir, const Array<GO> gFineNodesPerDir,
                 const LO numDimensions, RCP<const Teuchos::Comm<int> >& comm, const Xpetra::UnderlyingLib lib,
                 RCP<Xpetra::MultiVector<double,LocalOrdinal,GlobalOrdinal,Node>>&Coordinates)
  const {
    //TODO: Offsets for parallel
    //std::cout << "----------------------------------------------------------" << std::endl;
    //std::cout << "Entering GetCoordinates" << std::endl;
    //std::cout << "----------------------------------------------------------" << std::endl;
    GO  myOffset = 0;
    GO myZoffset = 0, myYoffset = 0, myXoffset = 0;
    LO lNumPoints = lFineNodesPerDir[0]*lFineNodesPerDir[1]*lFineNodesPerDir[2];
    GO gNumPoints = gFineNodesPerDir[0]*gFineNodesPerDir[1]*gFineNodesPerDir[2];
    Teuchos::Array<GO>     myGIDs(lNumPoints);
    Teuchos::Array<double> myXCoords(lNumPoints);
    Teuchos::Array<double> myYCoords(lNumPoints);
    Teuchos::Array<double> myZCoords(lNumPoints);
    for(LO k = 0; k < lFineNodesPerDir[2]; ++k) {
      for(LO j = 0; j < lFineNodesPerDir[1]; ++j) {
        for(LO i = 0; i < lFineNodesPerDir[0]; ++i) {
          myGIDs[k*lFineNodesPerDir[1]*lFineNodesPerDir[0] + j*lFineNodesPerDir[0] + i] = myOffset
            + k*gFineNodesPerDir[1]*gFineNodesPerDir[0] + j*gFineNodesPerDir[0] + i;
          myXCoords[k*lFineNodesPerDir[1]*lFineNodesPerDir[0] + j*lFineNodesPerDir[0] + i] =
            (i + myXoffset) / Teuchos::as<double>(gFineNodesPerDir[0] - 1);
          myYCoords[k*lFineNodesPerDir[1]*lFineNodesPerDir[0] + j*lFineNodesPerDir[0] + i] =
            (j + myYoffset) / Teuchos::as<double>(gFineNodesPerDir[1] - 1);
          myZCoords[k*lFineNodesPerDir[1]*lFineNodesPerDir[0] + j*lFineNodesPerDir[0] + i] =
            (k + myZoffset) / Teuchos::as<double>(gFineNodesPerDir[2] - 1);
        }
      }
    }
    //for(LO k = 0; k < lFineNodesPerDir[2]; ++k) {
    //  for(LO j = 0; j < lFineNodesPerDir[1]; ++j) {
    //    for(LO i = 0; i < lFineNodesPerDir[0]; ++i) {
    //      GO GID = myGIDs[k*lFineNodesPerDir[1]*lFineNodesPerDir[0] + j*lFineNodesPerDir[0] + i];
    //      double x = myXCoords[k*lFineNodesPerDir[1]*lFineNodesPerDir[0] + j*lFineNodesPerDir[0] + i];
    //      double y = myYCoords[k*lFineNodesPerDir[1]*lFineNodesPerDir[0] + j*lFineNodesPerDir[0] + i];
    //      double z = myZCoords[k*lFineNodesPerDir[1]*lFineNodesPerDir[0] + j*lFineNodesPerDir[0] + i];
    //      std::cout << "GID: " << GID << " x: " << x << " y: " << y << " z: " << z << std::endl;
    //    }
    //  }
    //}

    Teuchos::Array<Teuchos::ArrayView<const double> > myCoordinates(numDimensions);
    if(numDimensions == 1) {
      myCoordinates[0] = myXCoords();
    } else if(numDimensions == 2) {
      myCoordinates[0] = myXCoords();
      myCoordinates[1] = myYCoords();
    } else if(numDimensions == 3) {
      myCoordinates[0] = myXCoords();
      myCoordinates[1] = myYCoords();
      myCoordinates[2] = myZCoords();
    }

    // Create the map and store coordinates using the above array views
    RCP<Xpetra::Map<LO, GO, NO> > map =
    MapFactory::Build(lib, gNumPoints, myGIDs(), 0, comm);
    Coordinates = Xpetra::MultiVectorFactory<double,LO,GO,NO>::Build(map, myCoordinates(), numDimensions);
  }

  template <class Scalar, class LocalOrdinal, class GlobalOrdinal, class Node>
  void BlackBoxPFactory<Scalar, LocalOrdinal, GlobalOrdinal, Node>::GetNodeInfo(
                        const LO ie, const LO je, const LO ke,
                        const Array<LO> elementNodesPerDir,
                        int* type, LO& ind, int* orientation) const {
    //std::cout << "----------------------------------------------------------" << std::endl;
    //std::cout << "Entering GetNodeInfo" << std::endl;
    //std::cout << "----------------------------------------------------------" << std::endl;
    //std::cout << "ie = " << ie << " je = " << je << " ke = " << ke << std::endl;
    // Initialize flags with -1 to be able to catch issues easily
    *type = -1, ind = 0, *orientation = -1;
    if((ke == 0 || ke == elementNodesPerDir[2]-1)
             && (je == 0 || je == elementNodesPerDir[1]-1)
             && (ie == 0 || ie == elementNodesPerDir[0]-1)) {
      // Corner node
      *type = 0;
      ind  = 4*ke / (elementNodesPerDir[2]-1) + 2*je / (elementNodesPerDir[1]-1)
        + ie / (elementNodesPerDir[0]-1);
      // Ari: orientation doesn't matter so leave it -1?
    } else if(((ke == 0 || ke == elementNodesPerDir[2]-1)
               && (je == 0 || je == elementNodesPerDir[1]-1))
              || ((ke == 0 || ke == elementNodesPerDir[2]-1)
                  && (ie == 0 || ie == elementNodesPerDir[0]-1))
              || ((je == 0 || je == elementNodesPerDir[1]-1)
                  && (ie == 0 || ie == elementNodesPerDir[0]-1))) {
      // Edge node
      *type = 1;
      if(ke > 0) {ind += 2*(elementNodesPerDir[0] - 2 + elementNodesPerDir[1] - 2);}
      if(ke == elementNodesPerDir[2] - 1) {ind += 4*(elementNodesPerDir[2] - 2);}
      if((ke == 0) || (ke == elementNodesPerDir[2] - 1)) { // je or ie edges
        if(je == 0) {// jlo ie edge
          *orientation = 0;
          ind += ie - 1;
        } else if(je == elementNodesPerDir[1] - 1) {// jhi ie edge
          *orientation = 0;
          ind += 2*(elementNodesPerDir[1] - 2) + elementNodesPerDir[0] - 2 + ie - 1;
        } else {// ilo or ihi je edge
          *orientation = 1;
          ind += elementNodesPerDir[0] - 2 + 2*(je - 1) + ie / (elementNodesPerDir[0] - 1);
        }
      } else {// ke edges
        *orientation = 2;
        ind += 4*(ke - 1) + 2*(je/(elementNodesPerDir[1] - 1)) + ie / (elementNodesPerDir[0] - 1);
      }
    } else if ((ke == 0 || ke == elementNodesPerDir[2]-1)
                     || (je == 0 || je == elementNodesPerDir[1]-1)
                     || (ie == 0 || ie == elementNodesPerDir[0]-1)) {
      // Face node
      *type = 2;
      if(ke == 0) {// current node is on "bottom" face
        *orientation = 2;
        ind = (je - 1)*(elementNodesPerDir[0] - 2) + ie - 1;
      } else {
        // add nodes from "bottom" face
        ind += (elementNodesPerDir[1] - 2)*(elementNodesPerDir[0] - 2);
        // add nodes from side faces
        ind += 2*(ke - 1)*(elementNodesPerDir[1] - 2 + elementNodesPerDir[0] - 2);
        if(ke == elementNodesPerDir[2]-1) {// current node is on "top" face
          *orientation = 2;
          ind += (je - 1)*(elementNodesPerDir[0] - 2) + ie - 1;
        } else {// current node is on a side face
          if(je == 0) {
            *orientation = 1;
            ind += ie - 1;
          } else if(je == elementNodesPerDir[1] - 1) {
            *orientation = 1;
            ind += 2*(elementNodesPerDir[1] - 2) + elementNodesPerDir[0] - 2 + ie - 1;
          } else {
            *orientation = 0;
            ind += elementNodesPerDir[0] - 2 + 2*(je - 1) + ie / (elementNodesPerDir[0]-1);
          }
        }
      }
    } else {
      // Interior node
      *type = 3;
      ind  = (ke - 1)*(elementNodesPerDir[1] - 2)*(elementNodesPerDir[0] - 2)
        + (je - 1)*(elementNodesPerDir[0] - 2) + ie - 1;
    }
    //std::cout << "type = " << *type << " ind = " << ind << " orientation = " << *orientation << std::endl;
  } // GetNodeInfo()

  template <class Scalar, class LocalOrdinal, class GlobalOrdinal, class Node>
  void BlackBoxPFactory<Scalar, LocalOrdinal, GlobalOrdinal, Node>::sh_sort_permute(
                const typename Teuchos::Array<LocalOrdinal>::iterator& first1,
                const typename Teuchos::Array<LocalOrdinal>::iterator& last1,
                const typename Teuchos::Array<LocalOrdinal>::iterator& first2,
                const typename Teuchos::Array<LocalOrdinal>::iterator& last2) const
  {
    typedef typename std::iterator_traits<typename Teuchos::Array<LocalOrdinal>::iterator>::difference_type DT;
    DT n = last1 - first1;
    DT m = n / 2;
    DT z = Teuchos::OrdinalTraits<DT>::zero();
    while (m > z)
      {
        DT max = n - m;
        for (DT j = 0; j < max; j++)
          {
            for (DT k = j; k >= 0; k-=m)
              {
                if (first1[first2[k+m]] >= first1[first2[k]])
                  break;
                std::swap(first2[k+m], first2[k]);
              }
          }
        m = m/2;
      }
  }

} //namespace MueLu

#define MUELU_BLACKBOXPFACTORY_SHORT
#endif // MUELU_BLACKBOXPFACTORY_DEF_HPP
